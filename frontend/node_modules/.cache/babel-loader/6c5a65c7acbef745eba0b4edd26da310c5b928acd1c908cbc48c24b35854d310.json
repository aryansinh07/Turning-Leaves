{"ast":null,"code":"'use strict';\n\nvar libcharset = require('./charset');\nvar libbase64 = require('libbase64');\nvar libqp = require('libqp');\nvar mimetypes = require('./mimetypes');\nvar libmime = module.exports = {\n  /**\n   * Checks if a value is plaintext string (uses only printable 7bit chars)\n   *\n   * @param {String} value String to be tested\n   * @returns {Boolean} true if it is a plaintext string\n   */\n  isPlainText: function (value) {\n    if (typeof value !== 'string' || /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\u0080-\\uFFFF]/.test(value)) {\n      return false;\n    } else {\n      return true;\n    }\n  },\n  /**\n   * Checks if a multi line string containes lines longer than the selected value.\n   *\n   * Useful when detecting if a mail message needs any processing at all –\n   * if only plaintext characters are used and lines are short, then there is\n   * no need to encode the values in any way. If the value is plaintext but has\n   * longer lines then allowed, then use format=flowed\n   *\n   * @param {Number} lineLength Max line length to check for\n   * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars\n   */\n  hasLongerLines: function (str, lineLength) {\n    return new RegExp('^.{' + (lineLength + 1) + ',}', 'm').test(str);\n  },\n  /**\n   * Decodes a string from a format=flowed soft wrapping.\n   *\n   * @param {String} str Plaintext string with format=flowed to decode\n   * @param {Boolean} [delSp] If true, delete leading spaces (delsp=yes)\n   * @return {String} Mime decoded string\n   */\n  decodeFlowed: function (str, delSp) {\n    str = (str || '').toString();\n    return str.split(/\\r?\\n/).\n    // remove soft linebreaks\n    // soft linebreaks are added after space symbols\n    reduce(function (previousValue, currentValue, index) {\n      var body = previousValue;\n      if (delSp) {\n        // delsp adds spaces to text to be able to fold it\n        // these spaces can be removed once the text is unfolded\n        body = body.replace(/[ ]+$/, '');\n      }\n      if (/ $/.test(previousValue) && !/(^|\\n)\\-\\- $/.test(previousValue) || index === 1) {\n        return body + currentValue;\n      } else {\n        return body + '\\n' + currentValue;\n      }\n    }).\n    // remove whitespace stuffing\n    // http://tools.ietf.org/html/rfc3676#section-4.4\n    replace(/^ /gm, '');\n  },\n  /**\n   * Adds soft line breaks to content marked with format=flowed to\n   * ensure that no line in the message is never longer than lineLength\n   *\n   * @param {String} str Plaintext string that requires wrapping\n   * @param {Number} [lineLength=76] Maximum length of a line\n   * @return {String} String with forced line breaks\n   */\n  encodeFlowed: function (str, lineLength) {\n    lineLength = lineLength || 76;\n    var flowed = [];\n    str.split(/\\r?\\n/).forEach(function (line) {\n      flowed.push(libmime.foldLines(line.\n      // space stuffing http://tools.ietf.org/html/rfc3676#section-4.2\n      replace(/^( |From|>)/igm, ' $1'), lineLength, true));\n    });\n    return flowed.join('\\r\\n');\n  },\n  /**\n   * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)\n   *\n   * @param {String|Buffer} data String to be encoded\n   * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n   * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n   * @return {String} Single or several mime words joined together\n   */\n  encodeWord: function (data, mimeWordEncoding, maxLength) {\n    mimeWordEncoding = (mimeWordEncoding || 'Q').toString().toUpperCase().trim().charAt(0);\n    maxLength = maxLength || 0;\n    var encodedStr,\n      toCharset = 'UTF-8',\n      i,\n      len,\n      parts,\n      lpart,\n      chr;\n    if (maxLength && maxLength > 7 + toCharset.length) {\n      maxLength -= 7 + toCharset.length;\n    }\n    if (mimeWordEncoding === 'Q') {\n      // https://tools.ietf.org/html/rfc2047#section-5 rule (3)\n      encodedStr = libqp.encode(data).replace(/[^a-z0-9!*+\\-\\/=]/ig, function (chr) {\n        var ord = chr.charCodeAt(0).toString(16).toUpperCase();\n        if (chr === ' ') {\n          return '_';\n        } else {\n          return '=' + (ord.length === 1 ? '0' + ord : ord);\n        }\n      });\n    } else if (mimeWordEncoding === 'B') {\n      encodedStr = typeof data === 'string' ? data : libbase64.encode(data);\n      maxLength = maxLength ? Math.max(3, (maxLength - maxLength % 4) / 4 * 3) : 0;\n    }\n    if (maxLength && (mimeWordEncoding !== 'B' ? encodedStr : libbase64.encode(data)).length > maxLength) {\n      if (mimeWordEncoding === 'Q') {\n        encodedStr = splitMimeEncodedString(encodedStr, maxLength).join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n      } else {\n        // RFC2047 6.3 (2) states that encoded-word must include an integral number of characters, so no chopping unicode sequences\n        parts = [];\n        lpart = '';\n        for (i = 0, len = encodedStr.length; i < len; i++) {\n          chr = encodedStr.charAt(i);\n          // check if we can add this character to the existing string\n          // without breaking byte length limit\n          if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {\n            lpart += chr;\n          } else {\n            // we hit the length limit, so push the existing string and start over\n            parts.push(libbase64.encode(lpart));\n            lpart = chr;\n          }\n        }\n        if (lpart) {\n          parts.push(libbase64.encode(lpart));\n        }\n        if (parts.length > 1) {\n          encodedStr = parts.join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n        } else {\n          encodedStr = parts.join('');\n        }\n      }\n    } else if (mimeWordEncoding === 'B') {\n      encodedStr = libbase64.encode(data);\n    }\n    return '=?' + toCharset + '?' + mimeWordEncoding + '?' + encodedStr + (encodedStr.substr(-2) === '?=' ? '' : '?=');\n  },\n  /**\n   * Decode a complete mime word encoded string\n   *\n   * @param {String} str Mime word encoded string\n   * @return {String} Decoded unicode string\n   */\n  decodeWord: function (str) {\n    str = (str || '').toString().trim();\n    var fromCharset, encoding, match;\n    match = str.match(/^\\=\\?([\\w_\\-\\*]+)\\?([QqBb])\\?([^\\?]+)\\?\\=$/i);\n    if (!match) {\n      return str;\n    }\n\n    // RFC2231 added language tag to the encoding\n    // see: https://tools.ietf.org/html/rfc2231#section-5\n    // this implementation silently ignores this tag\n    fromCharset = match[1].split('*').shift();\n    encoding = (match[2] || 'Q').toString().toUpperCase();\n    str = (match[3] || '').replace(/_/g, ' ').replace(/ $/, '=20');\n    if (encoding === 'B') {\n      return libcharset.decode(libbase64.decode(str), fromCharset);\n    } else if (encoding === 'Q') {\n      return libcharset.decode(libqp.decode(str), fromCharset);\n    } else {\n      return str;\n    }\n  },\n  /**\n   * Finds word sequences with non ascii text and converts these to mime words\n   *\n   * @param {String|Buffer} data String to be encoded\n   * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n   * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n   * @param {String} [fromCharset='UTF-8'] Source sharacter set\n   * @return {String} String with possible mime words\n   */\n  encodeWords: function (data, mimeWordEncoding, maxLength, fromCharset) {\n    if (!fromCharset && typeof maxLength === 'string' && !maxLength.match(/^[0-9]+$/)) {\n      fromCharset = maxLength;\n      maxLength = undefined;\n    }\n    maxLength = maxLength || 0;\n    var decodedValue = libcharset.decode(libcharset.convert(data || '', fromCharset)),\n      encodedValue;\n    encodedValue = decodedValue.replace(/([^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*(?:\\s+[^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*\\s*)?)+(?=\\s|$)/g, function (match) {\n      return match.length ? libmime.encodeWord(match, mimeWordEncoding || 'Q', maxLength) : '';\n    });\n    return encodedValue;\n  },\n  /**\n   * Decode a string that might include one or several mime words\n   *\n   * @param {String} str String including some mime words that will be encoded\n   * @return {String} Decoded unicode string\n   */\n  decodeWords: function (str) {\n    return (str || '').toString().\n    // find base64 words that can be joined\n    replace(/(=\\?([^?]+)\\?[Bb]\\?[^?]+[^^=]\\?=)\\s*(?==\\?([^?]+)\\?[Bb]\\?[^?]+\\?=)/g, function (match, left, chLeft, chRight) {\n      // only mark to b64 chunks to be joined if charsets match\n      if (libcharset.normalizeCharset(chLeft || '').toLowerCase().trim() === libcharset.normalizeCharset(chRight || '').toLowerCase().trim()) {\n        // set a joiner marker\n        return left + '__\\x00JOIN\\x00__';\n      }\n      return match;\n    }).\n    // join base64 encoded words\n    replace(/(\\?=)?__\\x00JOIN\\x00__(=\\?([^?]+)\\?[Bb]\\?)?/g, '').\n    // remove spaces between mime encoded words\n    replace(/(=\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)\\s+(?==\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)/g, '$1').\n    // decode words\n    replace(/\\=\\?([\\w_\\-\\*]+)\\?([QqBb])\\?[^\\?]+\\?\\=/g, function (mimeWord) {\n      return libmime.decodeWord(mimeWord);\n    });\n  },\n  /**\n   * Splits a string by :\n   * The result is not mime word decoded, you need to do your own decoding based\n   * on the rules for the specific header key\n   *\n   * @param {String} headerLine Single header line, might include linebreaks as well if folded\n   * @return {Object} And object of {key, value}\n   */\n  decodeHeader: function (headerLine) {\n    var line = (headerLine || '').toString().replace(/(?:\\r?\\n|\\r)[ \\t]*/g, ' ').trim(),\n      match = line.match(/^\\s*([^:]+):(.*)$/),\n      key = (match && match[1] || '').trim().toLowerCase(),\n      value = (match && match[2] || '').trim();\n    return {\n      key: key,\n      value: value\n    };\n  },\n  /**\n   * Parses a block of header lines. Does not decode mime words as every\n   * header might have its own rules (eg. formatted email addresses and such)\n   *\n   * @param {String} headers Headers string\n   * @return {Object} An object of headers, where header keys are object keys. NB! Several values with the same key make up an Array\n   */\n  decodeHeaders: function (headers) {\n    var lines = headers.split(/\\r?\\n|\\r/),\n      headersObj = {},\n      header,\n      i,\n      len;\n    for (i = lines.length - 1; i >= 0; i--) {\n      if (i && lines[i].match(/^\\s/)) {\n        lines[i - 1] += '\\r\\n' + lines[i];\n        lines.splice(i, 1);\n      }\n    }\n    for (i = 0, len = lines.length; i < len; i++) {\n      header = libmime.decodeHeader(lines[i]);\n      if (!headersObj[header.key]) {\n        headersObj[header.key] = [header.value];\n      } else {\n        headersObj[header.key].push(header.value);\n      }\n    }\n    return headersObj;\n  },\n  /**\n   * Joins parsed header value together as 'value; param1=value1; param2=value2'\n   *\n   * @param {Object} structured Parsed header value\n   * @return {String} joined header value\n   */\n  buildHeaderValue: function (structured) {\n    var paramsArray = [];\n    Object.keys(structured.params || {}).forEach(function (param) {\n      // filename might include unicode characters so it is a special case\n      var value = structured.params[param];\n      if (!libmime.isPlainText(value) || value.length >= 75) {\n        libmime.buildHeaderParam(param, value, 50).forEach(function (encodedParam) {\n          if (!/[\\s\"\\\\;\\/=]|^[\\-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === '*') {\n            paramsArray.push(encodedParam.key + '=' + encodedParam.value);\n          } else {\n            paramsArray.push(encodedParam.key + '=' + JSON.stringify(encodedParam.value));\n          }\n        });\n      } else if (/[\\s'\"\\\\;\\/=]|^\\-/.test(value)) {\n        paramsArray.push(param + '=' + JSON.stringify(value));\n      } else {\n        paramsArray.push(param + '=' + value);\n      }\n    }.bind(this));\n    return structured.value + (paramsArray.length ? '; ' + paramsArray.join('; ') : '');\n  },\n  /**\n   * Parses a header value with key=value arguments into a structured\n   * object.\n   *\n   *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->\n   *   {\n   *     'value': 'text/plain',\n   *     'params': {\n   *       'charset': 'UTF-8'\n   *     }\n   *   }\n   *\n   * @param {String} str Header value\n   * @return {Object} Header value as a parsed structure\n   */\n  parseHeaderValue: function (str) {\n    var response = {\n        value: false,\n        params: {}\n      },\n      key = false,\n      value = '',\n      type = 'value',\n      quote = false,\n      escaped = false,\n      chr;\n    for (var i = 0, len = str.length; i < len; i++) {\n      chr = str.charAt(i);\n      if (type === 'key') {\n        if (chr === '=') {\n          key = value.trim().toLowerCase();\n          type = 'value';\n          value = '';\n          continue;\n        }\n        value += chr;\n      } else {\n        if (escaped) {\n          value += chr;\n        } else if (chr === '\\\\') {\n          escaped = true;\n          continue;\n        } else if (quote && chr === quote) {\n          quote = false;\n        } else if (!quote && chr === '\"') {\n          quote = chr;\n        } else if (!quote && chr === ';') {\n          if (key === false) {\n            response.value = value.trim();\n          } else {\n            response.params[key] = value.trim();\n          }\n          type = 'key';\n          value = '';\n        } else {\n          value += chr;\n        }\n        escaped = false;\n      }\n    }\n    if (type === 'value') {\n      if (key === false) {\n        response.value = value.trim();\n      } else {\n        response.params[key] = value.trim();\n      }\n    } else if (value.trim()) {\n      response.params[value.trim().toLowerCase()] = '';\n    }\n\n    // handle parameter value continuations\n    // https://tools.ietf.org/html/rfc2231#section-3\n\n    // preprocess values\n    Object.keys(response.params).forEach(function (key) {\n      var actualKey, nr, match, value;\n      if (match = key.match(/(\\*(\\d+)|\\*(\\d+)\\*|\\*)$/)) {\n        actualKey = key.substr(0, match.index);\n        nr = Number(match[2] || match[3]) || 0;\n        if (!response.params[actualKey] || typeof response.params[actualKey] !== 'object') {\n          response.params[actualKey] = {\n            charset: false,\n            values: []\n          };\n        }\n        value = response.params[key];\n        if (nr === 0 && match[0].substr(-1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {\n          response.params[actualKey].charset = match[1] || 'iso-8859-1';\n          value = match[2];\n        }\n        response.params[actualKey].values[nr] = value;\n\n        // remove the old reference\n        delete response.params[key];\n      }\n    });\n\n    // concatenate split rfc2231 strings and convert encoded strings to mime encoded words\n    Object.keys(response.params).forEach(function (key) {\n      var value;\n      if (response.params[key] && Array.isArray(response.params[key].values)) {\n        value = response.params[key].values.map(function (val) {\n          return val || '';\n        }).join('');\n        if (response.params[key].charset) {\n          // convert \"%AB\" to \"=?charset?Q?=AB?=\"\n          response.params[key] = '=?' + response.params[key].charset + '?Q?' + value.\n          // fix invalidly encoded chars\n          replace(/[=\\?_\\s]/g, function (s) {\n            var c = s.charCodeAt(0).toString(16);\n            if (s === ' ') {\n              return '_';\n            } else {\n              return '%' + (c.length < 2 ? '0' : '') + c;\n            }\n          }).\n          // change from urlencoding to percent encoding\n          replace(/%/g, '=') + '?=';\n        } else {\n          response.params[key] = value;\n        }\n      }\n    }.bind(this));\n    return response;\n  },\n  /**\n   * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)\n   * Useful for splitting long parameter values.\n   *\n   * For example\n   *      title=\"unicode string\"\n   * becomes\n   *     title*0*=utf-8''unicode\n   *     title*1*=%20string\n   *\n   * @param {String|Buffer} data String to be encoded\n   * @param {Number} [maxLength=50] Max length for generated chunks\n   * @param {String} [fromCharset='UTF-8'] Source sharacter set\n   * @return {Array} A list of encoded keys and headers\n   */\n  buildHeaderParam: function (key, data, maxLength, fromCharset) {\n    var list = [];\n    var encodedStr = typeof data === 'string' ? data : libmime.decode(data, fromCharset);\n    var encodedStrArr;\n    var chr, ord;\n    var line;\n    var startPos = 0;\n    var isEncoded = false;\n    var i, len;\n    maxLength = maxLength || 50;\n\n    // process ascii only text\n    if (libmime.isPlainText(data)) {\n      // check if conversion is even needed\n      if (encodedStr.length <= maxLength) {\n        return [{\n          key: key,\n          value: encodedStr\n        }];\n      }\n      encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), function (str) {\n        list.push({\n          line: str\n        });\n        return '';\n      });\n      if (encodedStr) {\n        list.push({\n          line: encodedStr\n        });\n      }\n    } else {\n      if (/[\\uD800-\\uDBFF]/.test(encodedStr)) {\n        // string containts surrogate pairs, so normalize it to an array of bytes\n        encodedStrArr = [];\n        for (i = 0, len = encodedStr.length; i < len; i++) {\n          chr = encodedStr.charAt(i);\n          ord = chr.charCodeAt(0);\n          if (ord >= 0xD800 && ord <= 0xDBFF && i < len - 1) {\n            chr += encodedStr.charAt(i + 1);\n            encodedStrArr.push(chr);\n            i++;\n          } else {\n            encodedStrArr.push(chr);\n          }\n        }\n        encodedStr = encodedStrArr;\n      }\n\n      // first line includes the charset and language info and needs to be encoded\n      // even if it does not contain any unicode characters\n      line = 'utf-8\\'\\'';\n      isEncoded = true;\n      startPos = 0;\n\n      // process text with unicode or special chars\n      for (i = 0, len = encodedStr.length; i < len; i++) {\n        chr = encodedStr[i];\n        if (isEncoded) {\n          chr = safeEncodeURIComponent(chr);\n        } else {\n          // try to urlencode current char\n          chr = chr === ' ' ? chr : safeEncodeURIComponent(chr);\n          // By default it is not required to encode a line, the need\n          // only appears when the string contains unicode or special chars\n          // in this case we start processing the line over and encode all chars\n          if (chr !== encodedStr[i]) {\n            // Check if it is even possible to add the encoded char to the line\n            // If not, there is no reason to use this line, just push it to the list\n            // and start a new line with the char that needs encoding\n            if ((safeEncodeURIComponent(line) + chr).length >= maxLength) {\n              list.push({\n                line: line,\n                encoded: isEncoded\n              });\n              line = '';\n              startPos = i - 1;\n            } else {\n              isEncoded = true;\n              i = startPos;\n              line = '';\n              continue;\n            }\n          }\n        }\n\n        // if the line is already too long, push it to the list and start a new one\n        if ((line + chr).length >= maxLength) {\n          list.push({\n            line: line,\n            encoded: isEncoded\n          });\n          line = chr = encodedStr[i] === ' ' ? ' ' : safeEncodeURIComponent(encodedStr[i]);\n          if (chr === encodedStr[i]) {\n            isEncoded = false;\n            startPos = i - 1;\n          } else {\n            isEncoded = true;\n          }\n        } else {\n          line += chr;\n        }\n      }\n      if (line) {\n        list.push({\n          line: line,\n          encoded: isEncoded\n        });\n      }\n    }\n    return list.map(function (item, i) {\n      return {\n        // encoded lines: {name}*{part}*\n        // unencoded lines: {name}*{part}\n        // if any line needs to be encoded then the first line (part==0) is always encoded\n        key: key + '*' + i + (item.encoded ? '*' : ''),\n        value: item.line\n      };\n    });\n  },\n  /**\n   * Returns file extension for a content type string. If no suitable extensions\n   * are found, 'bin' is used as the default extension\n   *\n   * @param {String} mimeType Content type to be checked for\n   * @return {String} File extension\n   */\n  detectExtension: function (mimeType) {\n    mimeType = (mimeType || '').toString().toLowerCase().replace(/\\s/g, '');\n    if (!(mimeType in mimetypes.list)) {\n      return 'bin';\n    }\n    if (typeof mimetypes.list[mimeType] === 'string') {\n      return mimetypes.list[mimeType];\n    }\n    var mimeParts = mimeType.split('/');\n\n    // search for name match\n    for (var i = 0, len = mimetypes.list[mimeType].length; i < len; i++) {\n      if (mimeParts[1] === mimetypes.list[mimeType][i]) {\n        return mimetypes.list[mimeType][i];\n      }\n    }\n\n    // use the first one\n    return mimetypes.list[mimeType][0] !== '*' ? mimetypes.list[mimeType][0] : 'bin';\n  },\n  /**\n   * Returns content type for a file extension. If no suitable content types\n   * are found, 'application/octet-stream' is used as the default content type\n   *\n   * @param {String} extension Extension to be checked for\n   * @return {String} File extension\n   */\n  detectMimeType: function (extension) {\n    extension = (extension || '').toString().toLowerCase().replace(/\\s/g, '').replace(/^\\./g, '').split('.').pop();\n    if (!(extension in mimetypes.extensions)) {\n      return 'application/octet-stream';\n    }\n    if (typeof mimetypes.extensions[extension] === 'string') {\n      return mimetypes.extensions[extension];\n    }\n    var mimeParts;\n\n    // search for name match\n    for (var i = 0, len = mimetypes.extensions[extension].length; i < len; i++) {\n      mimeParts = mimetypes.extensions[extension][i].split('/');\n      if (mimeParts[1] === extension) {\n        return mimetypes.extensions[extension][i];\n      }\n    }\n\n    // use the first one\n    return mimetypes.extensions[extension][0];\n  },\n  /**\n   * Folds long lines, useful for folding header lines (afterSpace=false) and\n   * flowed text (afterSpace=true)\n   *\n   * @param {String} str String to be folded\n   * @param {Number} [lineLength=76] Maximum length of a line\n   * @param {Boolean} afterSpace If true, leave a space in th end of a line\n   * @return {String} String with folded lines\n   */\n  foldLines: function (str, lineLength, afterSpace) {\n    str = (str || '').toString();\n    lineLength = lineLength || 76;\n    var pos = 0,\n      len = str.length,\n      result = '',\n      line,\n      match;\n    while (pos < len) {\n      line = str.substr(pos, lineLength);\n      if (line.length < lineLength) {\n        result += line;\n        break;\n      }\n      if (match = line.match(/^[^\\n\\r]*(\\r?\\n|\\r)/)) {\n        line = match[0];\n        result += line;\n        pos += line.length;\n        continue;\n      } else if ((match = line.match(/(\\s+)[^\\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {\n        line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)));\n      } else if (match = str.substr(pos + line.length).match(/^[^\\s]+(\\s*)/)) {\n        line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0));\n      }\n      result += line;\n      pos += line.length;\n      if (pos < len) {\n        result += '\\r\\n';\n      }\n    }\n    return result;\n  }\n};\n\n/**\n * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n *\n * @param {String} str Mime encoded string to be split up\n * @param {Number} maxlen Maximum length of characters for one part (minimum 12)\n * @return {Array} Split string\n */\nfunction splitMimeEncodedString(str, maxlen) {\n  var curLine,\n    match,\n    chr,\n    done,\n    lines = [];\n\n  // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n  maxlen = Math.max(maxlen || 0, 12);\n  while (str.length) {\n    curLine = str.substr(0, maxlen);\n\n    // move incomplete escaped char back to main\n    if (match = curLine.match(/\\=[0-9A-F]?$/i)) {\n      curLine = curLine.substr(0, match.index);\n    }\n    done = false;\n    while (!done) {\n      done = true;\n      // check if not middle of a unicode char sequence\n      if (match = str.substr(curLine.length).match(/^\\=([0-9A-F]{2})/i)) {\n        chr = parseInt(match[1], 16);\n        // invalid sequence, move one char back anc recheck\n        if (chr < 0xC2 && chr > 0x7F) {\n          curLine = curLine.substr(0, curLine.length - 3);\n          done = false;\n        }\n      }\n    }\n    if (curLine.length) {\n      lines.push(curLine);\n    }\n    str = str.substr(curLine.length);\n  }\n  return lines;\n}\nfunction encodeURICharComponent(chr) {\n  var i, len, ord;\n  var res = '';\n  ord = chr.charCodeAt(0).toString(16).toUpperCase();\n  if (ord.length % 2) {\n    ord = '0' + ord;\n  }\n  if (ord.length > 2) {\n    for (i = 0, len = ord.length / 2; i < len; i++) {\n      res += '%' + ord.substr(i, 2);\n    }\n  } else {\n    res += '%' + ord;\n  }\n  return res;\n}\nfunction safeEncodeURIComponent(str) {\n  str = (str || '').toString();\n  try {\n    // might throw if we try to encode invalid sequences, eg. partial emoji\n    str = encodeURIComponent(str);\n  } catch (E) {\n    // should never run\n    return str.replace(/[^\\x00-\\x1F *'()<>@,;:\\\\\"\\[\\]?=\\u007F-\\uFFFF]+/g, '');\n  }\n\n  // ensure chars that are not handled by encodeURICompent are converted as well\n  return str.replace(/[\\x00-\\x1F *'()<>@,;:\\\\\"\\[\\]?=\\u007F-\\uFFFF]/g, encodeURICharComponent);\n}","map":{"version":3,"names":["libcharset","require","libbase64","libqp","mimetypes","libmime","module","exports","isPlainText","value","test","hasLongerLines","str","lineLength","RegExp","decodeFlowed","delSp","toString","split","reduce","previousValue","currentValue","index","body","replace","encodeFlowed","flowed","forEach","line","push","foldLines","join","encodeWord","data","mimeWordEncoding","maxLength","toUpperCase","trim","charAt","encodedStr","toCharset","i","len","parts","lpart","chr","length","encode","ord","charCodeAt","Math","max","splitMimeEncodedString","Buffer","byteLength","substr","decodeWord","fromCharset","encoding","match","shift","decode","encodeWords","undefined","decodedValue","convert","encodedValue","decodeWords","left","chLeft","chRight","normalizeCharset","toLowerCase","mimeWord","decodeHeader","headerLine","key","decodeHeaders","headers","lines","headersObj","header","splice","buildHeaderValue","structured","paramsArray","Object","keys","params","param","buildHeaderParam","encodedParam","JSON","stringify","bind","parseHeaderValue","response","type","quote","escaped","actualKey","nr","Number","charset","values","Array","isArray","map","val","s","c","list","encodedStrArr","startPos","isEncoded","safeEncodeURIComponent","encoded","item","detectExtension","mimeType","mimeParts","detectMimeType","extension","pop","extensions","afterSpace","pos","result","maxlen","curLine","done","parseInt","encodeURICharComponent","res","encodeURIComponent","E"],"sources":["C:/Users/Admin/OneDrive/Desktop/Online Book Thrift Store/frontend/node_modules/mailcomposer/node_modules/libmime/lib/libmime.js"],"sourcesContent":["'use strict';\n\nvar libcharset = require('./charset');\nvar libbase64 = require('libbase64');\nvar libqp = require('libqp');\nvar mimetypes = require('./mimetypes');\n\nvar libmime = module.exports = {\n\n    /**\n     * Checks if a value is plaintext string (uses only printable 7bit chars)\n     *\n     * @param {String} value String to be tested\n     * @returns {Boolean} true if it is a plaintext string\n     */\n    isPlainText: function (value) {\n        if (typeof value !== 'string' || /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\u0080-\\uFFFF]/.test(value)) {\n            return false;\n        } else {\n            return true;\n        }\n    },\n\n    /**\n     * Checks if a multi line string containes lines longer than the selected value.\n     *\n     * Useful when detecting if a mail message needs any processing at all –\n     * if only plaintext characters are used and lines are short, then there is\n     * no need to encode the values in any way. If the value is plaintext but has\n     * longer lines then allowed, then use format=flowed\n     *\n     * @param {Number} lineLength Max line length to check for\n     * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars\n     */\n    hasLongerLines: function (str, lineLength) {\n        return new RegExp('^.{' + (lineLength + 1) + ',}', 'm').test(str);\n    },\n\n    /**\n     * Decodes a string from a format=flowed soft wrapping.\n     *\n     * @param {String} str Plaintext string with format=flowed to decode\n     * @param {Boolean} [delSp] If true, delete leading spaces (delsp=yes)\n     * @return {String} Mime decoded string\n     */\n    decodeFlowed: function (str, delSp) {\n        str = (str || '').toString();\n\n        return str.\n        split(/\\r?\\n/).\n            // remove soft linebreaks\n            // soft linebreaks are added after space symbols\n        reduce(\n                function (previousValue, currentValue, index) {\n                    var body = previousValue;\n                    if (delSp) {\n                        // delsp adds spaces to text to be able to fold it\n                        // these spaces can be removed once the text is unfolded\n                        body = body.replace(/[ ]+$/, '');\n                    }\n                    if (/ $/.test(previousValue) && !/(^|\\n)\\-\\- $/.test(previousValue) || index === 1) {\n                        return body + currentValue;\n                    } else {\n                        return body + '\\n' + currentValue;\n                    }\n                }\n            ).\n            // remove whitespace stuffing\n            // http://tools.ietf.org/html/rfc3676#section-4.4\n        replace(/^ /gm, '');\n    },\n\n    /**\n     * Adds soft line breaks to content marked with format=flowed to\n     * ensure that no line in the message is never longer than lineLength\n     *\n     * @param {String} str Plaintext string that requires wrapping\n     * @param {Number} [lineLength=76] Maximum length of a line\n     * @return {String} String with forced line breaks\n     */\n    encodeFlowed: function (str, lineLength) {\n        lineLength = lineLength || 76;\n\n        var flowed = [];\n        str.split(/\\r?\\n/).forEach(function (line) {\n            flowed.push(libmime.foldLines(line.\n                // space stuffing http://tools.ietf.org/html/rfc3676#section-4.2\n                replace(/^( |From|>)/igm, ' $1'),\n                lineLength, true));\n        });\n        return flowed.join('\\r\\n');\n    },\n\n    /**\n     * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)\n     *\n     * @param {String|Buffer} data String to be encoded\n     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n     * @return {String} Single or several mime words joined together\n     */\n    encodeWord: function (data, mimeWordEncoding, maxLength) {\n        mimeWordEncoding = (mimeWordEncoding || 'Q').toString().toUpperCase().trim().charAt(0);\n        maxLength = maxLength || 0;\n\n        var encodedStr,\n            toCharset = 'UTF-8',\n            i, len, parts, lpart, chr;\n\n        if (maxLength && maxLength > 7 + toCharset.length) {\n            maxLength -= (7 + toCharset.length);\n        }\n\n        if (mimeWordEncoding === 'Q') {\n            // https://tools.ietf.org/html/rfc2047#section-5 rule (3)\n            encodedStr = libqp.encode(data).replace(/[^a-z0-9!*+\\-\\/=]/ig, function (chr) {\n                var ord = chr.charCodeAt(0).toString(16).toUpperCase();\n                if (chr === ' ') {\n                    return '_';\n                } else {\n                    return '=' + (ord.length === 1 ? '0' + ord : ord);\n                }\n            });\n        } else if (mimeWordEncoding === 'B') {\n            encodedStr = typeof data === 'string' ? data : libbase64.encode(data);\n            maxLength = maxLength ? Math.max(3, (maxLength - maxLength % 4) / 4 * 3) : 0;\n        }\n\n        if (maxLength && (mimeWordEncoding !== 'B' ? encodedStr : libbase64.encode(data)).length > maxLength) {\n            if (mimeWordEncoding === 'Q') {\n                encodedStr = splitMimeEncodedString(encodedStr, maxLength).join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n            } else {\n                // RFC2047 6.3 (2) states that encoded-word must include an integral number of characters, so no chopping unicode sequences\n                parts = [];\n                lpart = '';\n                for (i = 0, len = encodedStr.length; i < len; i++) {\n                    chr = encodedStr.charAt(i);\n                    // check if we can add this character to the existing string\n                    // without breaking byte length limit\n                    if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {\n                        lpart += chr;\n                    } else {\n                        // we hit the length limit, so push the existing string and start over\n                        parts.push(libbase64.encode(lpart));\n                        lpart = chr;\n                    }\n                }\n                if (lpart) {\n                    parts.push(libbase64.encode(lpart));\n                }\n\n                if (parts.length > 1) {\n                    encodedStr = parts.join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n                } else {\n                    encodedStr = parts.join('');\n                }\n            }\n        } else if (mimeWordEncoding === 'B') {\n            encodedStr = libbase64.encode(data);\n        }\n\n        return '=?' + toCharset + '?' + mimeWordEncoding + '?' + encodedStr + (encodedStr.substr(-2) === '?=' ? '' : '?=');\n    },\n\n    /**\n     * Decode a complete mime word encoded string\n     *\n     * @param {String} str Mime word encoded string\n     * @return {String} Decoded unicode string\n     */\n    decodeWord: function (str) {\n        str = (str || '').toString().trim();\n\n        var fromCharset, encoding, match;\n\n        match = str.match(/^\\=\\?([\\w_\\-\\*]+)\\?([QqBb])\\?([^\\?]+)\\?\\=$/i);\n        if (!match) {\n            return str;\n        }\n\n        // RFC2231 added language tag to the encoding\n        // see: https://tools.ietf.org/html/rfc2231#section-5\n        // this implementation silently ignores this tag\n        fromCharset = match[1].split('*').shift();\n\n        encoding = (match[2] || 'Q').toString().toUpperCase();\n        str = (match[3] || '').replace(/_/g, ' ').replace(/ $/, '=20');\n\n        if (encoding === 'B') {\n            return libcharset.decode(libbase64.decode(str), fromCharset);\n        } else if (encoding === 'Q') {\n            return libcharset.decode(libqp.decode(str), fromCharset);\n        } else {\n            return str;\n        }\n    },\n\n    /**\n     * Finds word sequences with non ascii text and converts these to mime words\n     *\n     * @param {String|Buffer} data String to be encoded\n     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n     * @param {String} [fromCharset='UTF-8'] Source sharacter set\n     * @return {String} String with possible mime words\n     */\n    encodeWords: function (data, mimeWordEncoding, maxLength, fromCharset) {\n        if (!fromCharset && typeof maxLength === 'string' && !maxLength.match(/^[0-9]+$/)) {\n            fromCharset = maxLength;\n            maxLength = undefined;\n        }\n\n        maxLength = maxLength || 0;\n\n        var decodedValue = libcharset.decode(libcharset.convert((data || ''), fromCharset)),\n            encodedValue;\n\n        encodedValue = decodedValue.replace(/([^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*(?:\\s+[^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*\\s*)?)+(?=\\s|$)/g, function (match) {\n            return match.length ? libmime.encodeWord(match, mimeWordEncoding || 'Q', maxLength) : '';\n        });\n\n        return encodedValue;\n    },\n\n    /**\n     * Decode a string that might include one or several mime words\n     *\n     * @param {String} str String including some mime words that will be encoded\n     * @return {String} Decoded unicode string\n     */\n    decodeWords: function (str) {\n        return (str || '').toString().\n\n        // find base64 words that can be joined\n        replace(/(=\\?([^?]+)\\?[Bb]\\?[^?]+[^^=]\\?=)\\s*(?==\\?([^?]+)\\?[Bb]\\?[^?]+\\?=)/g,\n            function (match, left, chLeft, chRight) {\n                // only mark to b64 chunks to be joined if charsets match\n                if (libcharset.normalizeCharset(chLeft || '').toLowerCase().trim() === libcharset.normalizeCharset(chRight || '').toLowerCase().trim()) {\n                    // set a joiner marker\n                    return left + '__\\x00JOIN\\x00__';\n                }\n                return match;\n            }).\n\n        // join base64 encoded words\n        replace(/(\\?=)?__\\x00JOIN\\x00__(=\\?([^?]+)\\?[Bb]\\?)?/g, '').\n\n        // remove spaces between mime encoded words\n        replace(/(=\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)\\s+(?==\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)/g, '$1').\n\n        // decode words\n        replace(/\\=\\?([\\w_\\-\\*]+)\\?([QqBb])\\?[^\\?]+\\?\\=/g, function (mimeWord) {\n            return libmime.decodeWord(mimeWord);\n        });\n    },\n\n    /**\n     * Splits a string by :\n     * The result is not mime word decoded, you need to do your own decoding based\n     * on the rules for the specific header key\n     *\n     * @param {String} headerLine Single header line, might include linebreaks as well if folded\n     * @return {Object} And object of {key, value}\n     */\n    decodeHeader: function (headerLine) {\n        var line = (headerLine || '').toString().replace(/(?:\\r?\\n|\\r)[ \\t]*/g, ' ').trim(),\n            match = line.match(/^\\s*([^:]+):(.*)$/),\n            key = (match && match[1] || '').trim().toLowerCase(),\n            value = (match && match[2] || '').trim();\n\n        return {\n            key: key,\n            value: value\n        };\n    },\n\n    /**\n     * Parses a block of header lines. Does not decode mime words as every\n     * header might have its own rules (eg. formatted email addresses and such)\n     *\n     * @param {String} headers Headers string\n     * @return {Object} An object of headers, where header keys are object keys. NB! Several values with the same key make up an Array\n     */\n    decodeHeaders: function (headers) {\n        var lines = headers.split(/\\r?\\n|\\r/),\n            headersObj = {},\n            header,\n            i, len;\n\n        for (i = lines.length - 1; i >= 0; i--) {\n            if (i && lines[i].match(/^\\s/)) {\n                lines[i - 1] += '\\r\\n' + lines[i];\n                lines.splice(i, 1);\n            }\n        }\n\n        for (i = 0, len = lines.length; i < len; i++) {\n            header = libmime.decodeHeader(lines[i]);\n            if (!headersObj[header.key]) {\n                headersObj[header.key] = [header.value];\n            } else {\n                headersObj[header.key].push(header.value);\n            }\n        }\n\n        return headersObj;\n    },\n\n    /**\n     * Joins parsed header value together as 'value; param1=value1; param2=value2'\n     *\n     * @param {Object} structured Parsed header value\n     * @return {String} joined header value\n     */\n    buildHeaderValue: function (structured) {\n        var paramsArray = [];\n\n        Object.keys(structured.params || {}).forEach(function (param) {\n            // filename might include unicode characters so it is a special case\n            var value = structured.params[param];\n            if (!libmime.isPlainText(value) || value.length >= 75) {\n                libmime.buildHeaderParam(param, value, 50).forEach(function (encodedParam) {\n                    if (!/[\\s\"\\\\;\\/=]|^[\\-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === '*') {\n                        paramsArray.push(encodedParam.key + '=' + encodedParam.value);\n                    } else {\n                        paramsArray.push(encodedParam.key + '=' + JSON.stringify(encodedParam.value));\n                    }\n                });\n            } else if (/[\\s'\"\\\\;\\/=]|^\\-/.test(value)) {\n                paramsArray.push(param + '=' + JSON.stringify(value));\n            } else {\n                paramsArray.push(param + '=' + value);\n            }\n        }.bind(this));\n\n        return structured.value + (paramsArray.length ? '; ' + paramsArray.join('; ') : '');\n    },\n\n    /**\n     * Parses a header value with key=value arguments into a structured\n     * object.\n     *\n     *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->\n     *   {\n     *     'value': 'text/plain',\n     *     'params': {\n     *       'charset': 'UTF-8'\n     *     }\n     *   }\n     *\n     * @param {String} str Header value\n     * @return {Object} Header value as a parsed structure\n     */\n    parseHeaderValue: function (str) {\n        var response = {\n                value: false,\n                params: {}\n            },\n            key = false,\n            value = '',\n            type = 'value',\n            quote = false,\n            escaped = false,\n            chr;\n\n        for (var i = 0, len = str.length; i < len; i++) {\n            chr = str.charAt(i);\n            if (type === 'key') {\n                if (chr === '=') {\n                    key = value.trim().toLowerCase();\n                    type = 'value';\n                    value = '';\n                    continue;\n                }\n                value += chr;\n            } else {\n                if (escaped) {\n                    value += chr;\n                } else if (chr === '\\\\') {\n                    escaped = true;\n                    continue;\n                } else if (quote && chr === quote) {\n                    quote = false;\n                } else if (!quote && chr === '\"') {\n                    quote = chr;\n                } else if (!quote && chr === ';') {\n                    if (key === false) {\n                        response.value = value.trim();\n                    } else {\n                        response.params[key] = value.trim();\n                    }\n                    type = 'key';\n                    value = '';\n                } else {\n                    value += chr;\n                }\n                escaped = false;\n\n            }\n        }\n\n        if (type === 'value') {\n            if (key === false) {\n                response.value = value.trim();\n            } else {\n                response.params[key] = value.trim();\n            }\n        } else if (value.trim()) {\n            response.params[value.trim().toLowerCase()] = '';\n        }\n\n        // handle parameter value continuations\n        // https://tools.ietf.org/html/rfc2231#section-3\n\n        // preprocess values\n        Object.keys(response.params).forEach(function (key) {\n            var actualKey, nr, match, value;\n            if ((match = key.match(/(\\*(\\d+)|\\*(\\d+)\\*|\\*)$/))) {\n                actualKey = key.substr(0, match.index);\n                nr = Number(match[2] || match[3]) || 0;\n\n                if (!response.params[actualKey] || typeof response.params[actualKey] !== 'object') {\n                    response.params[actualKey] = {\n                        charset: false,\n                        values: []\n                    };\n                }\n\n                value = response.params[key];\n\n                if (nr === 0 && match[0].substr(-1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {\n                    response.params[actualKey].charset = match[1] || 'iso-8859-1';\n                    value = match[2];\n                }\n\n                response.params[actualKey].values[nr] = value;\n\n                // remove the old reference\n                delete response.params[key];\n            }\n        });\n\n        // concatenate split rfc2231 strings and convert encoded strings to mime encoded words\n        Object.keys(response.params).forEach(function (key) {\n            var value;\n            if (response.params[key] && Array.isArray(response.params[key].values)) {\n                value = response.params[key].values.map(function (val) {\n                    return val || '';\n                }).join('');\n\n                if (response.params[key].charset) {\n                    // convert \"%AB\" to \"=?charset?Q?=AB?=\"\n                    response.params[key] = '=?' +\n                        response.params[key].charset +\n                        '?Q?' +\n                        value.\n                        // fix invalidly encoded chars\n                    replace(/[=\\?_\\s]/g,\n                            function (s) {\n                                var c = s.charCodeAt(0).toString(16);\n                                if (s === ' ') {\n                                    return '_';\n                                } else {\n                                    return '%' + (c.length < 2 ? '0' : '') + c;\n                                }\n                            }\n                        ).\n                        // change from urlencoding to percent encoding\n                    replace(/%/g, '=') +\n                        '?=';\n                } else {\n                    response.params[key] = value;\n                }\n            }\n        }.bind(this));\n\n        return response;\n    },\n\n    /**\n     * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)\n     * Useful for splitting long parameter values.\n     *\n     * For example\n     *      title=\"unicode string\"\n     * becomes\n     *     title*0*=utf-8''unicode\n     *     title*1*=%20string\n     *\n     * @param {String|Buffer} data String to be encoded\n     * @param {Number} [maxLength=50] Max length for generated chunks\n     * @param {String} [fromCharset='UTF-8'] Source sharacter set\n     * @return {Array} A list of encoded keys and headers\n     */\n    buildHeaderParam: function (key, data, maxLength, fromCharset) {\n        var list = [];\n        var encodedStr = typeof data === 'string' ? data : libmime.decode(data, fromCharset);\n        var encodedStrArr;\n        var chr, ord;\n        var line;\n        var startPos = 0;\n        var isEncoded = false;\n        var i, len;\n\n        maxLength = maxLength || 50;\n\n        // process ascii only text\n        if (libmime.isPlainText(data)) {\n\n            // check if conversion is even needed\n            if (encodedStr.length <= maxLength) {\n                return [{\n                    key: key,\n                    value: encodedStr\n                }];\n            }\n\n            encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), function (str) {\n                list.push({\n                    line: str\n                });\n                return '';\n            });\n\n            if (encodedStr) {\n                list.push({\n                    line: encodedStr\n                });\n            }\n\n        } else {\n\n            if (/[\\uD800-\\uDBFF]/.test(encodedStr)) {\n                // string containts surrogate pairs, so normalize it to an array of bytes\n                encodedStrArr = [];\n                for (i = 0, len = encodedStr.length; i < len; i++) {\n                    chr = encodedStr.charAt(i);\n                    ord = chr.charCodeAt(0);\n                    if (ord >= 0xD800 && ord <= 0xDBFF && i < len - 1) {\n                        chr += encodedStr.charAt(i + 1);\n                        encodedStrArr.push(chr);\n                        i++;\n                    } else {\n                        encodedStrArr.push(chr);\n                    }\n                }\n                encodedStr = encodedStrArr;\n            }\n\n            // first line includes the charset and language info and needs to be encoded\n            // even if it does not contain any unicode characters\n            line = 'utf-8\\'\\'';\n            isEncoded = true;\n            startPos = 0;\n\n            // process text with unicode or special chars\n            for (i = 0, len = encodedStr.length; i < len; i++) {\n\n                chr = encodedStr[i];\n\n                if (isEncoded) {\n                    chr = safeEncodeURIComponent(chr);\n                } else {\n                    // try to urlencode current char\n                    chr = chr === ' ' ? chr : safeEncodeURIComponent(chr);\n                    // By default it is not required to encode a line, the need\n                    // only appears when the string contains unicode or special chars\n                    // in this case we start processing the line over and encode all chars\n                    if (chr !== encodedStr[i]) {\n                        // Check if it is even possible to add the encoded char to the line\n                        // If not, there is no reason to use this line, just push it to the list\n                        // and start a new line with the char that needs encoding\n                        if ((safeEncodeURIComponent(line) + chr).length >= maxLength) {\n                            list.push({\n                                line: line,\n                                encoded: isEncoded\n                            });\n                            line = '';\n                            startPos = i - 1;\n                        } else {\n                            isEncoded = true;\n                            i = startPos;\n                            line = '';\n                            continue;\n                        }\n                    }\n                }\n\n                // if the line is already too long, push it to the list and start a new one\n                if ((line + chr).length >= maxLength) {\n                    list.push({\n                        line: line,\n                        encoded: isEncoded\n                    });\n                    line = chr = encodedStr[i] === ' ' ? ' ' : safeEncodeURIComponent(encodedStr[i]);\n                    if (chr === encodedStr[i]) {\n                        isEncoded = false;\n                        startPos = i - 1;\n                    } else {\n                        isEncoded = true;\n                    }\n                } else {\n                    line += chr;\n                }\n            }\n\n            if (line) {\n                list.push({\n                    line: line,\n                    encoded: isEncoded\n                });\n            }\n        }\n\n        return list.map(function (item, i) {\n            return {\n                // encoded lines: {name}*{part}*\n                // unencoded lines: {name}*{part}\n                // if any line needs to be encoded then the first line (part==0) is always encoded\n                key: key + '*' + i + (item.encoded ? '*' : ''),\n                value: item.line\n            };\n        });\n    },\n\n\n    /**\n     * Returns file extension for a content type string. If no suitable extensions\n     * are found, 'bin' is used as the default extension\n     *\n     * @param {String} mimeType Content type to be checked for\n     * @return {String} File extension\n     */\n    detectExtension: function (mimeType) {\n        mimeType = (mimeType || '').toString().toLowerCase().replace(/\\s/g, '');\n        if (!(mimeType in mimetypes.list)) {\n            return 'bin';\n        }\n\n        if (typeof mimetypes.list[mimeType] === 'string') {\n            return mimetypes.list[mimeType];\n        }\n\n        var mimeParts = mimeType.split('/');\n\n        // search for name match\n        for (var i = 0, len = mimetypes.list[mimeType].length; i < len; i++) {\n            if (mimeParts[1] === mimetypes.list[mimeType][i]) {\n                return mimetypes.list[mimeType][i];\n            }\n        }\n\n        // use the first one\n        return mimetypes.list[mimeType][0] !== '*' ? mimetypes.list[mimeType][0] : 'bin';\n    },\n\n    /**\n     * Returns content type for a file extension. If no suitable content types\n     * are found, 'application/octet-stream' is used as the default content type\n     *\n     * @param {String} extension Extension to be checked for\n     * @return {String} File extension\n     */\n    detectMimeType: function (extension) {\n        extension = (extension || '').toString().toLowerCase().replace(/\\s/g, '').replace(/^\\./g, '').split('.').pop();\n\n        if (!(extension in mimetypes.extensions)) {\n            return 'application/octet-stream';\n        }\n\n        if (typeof mimetypes.extensions[extension] === 'string') {\n            return mimetypes.extensions[extension];\n        }\n\n        var mimeParts;\n\n        // search for name match\n        for (var i = 0, len = mimetypes.extensions[extension].length; i < len; i++) {\n            mimeParts = mimetypes.extensions[extension][i].split('/');\n            if (mimeParts[1] === extension) {\n                return mimetypes.extensions[extension][i];\n            }\n        }\n\n        // use the first one\n        return mimetypes.extensions[extension][0];\n    },\n\n    /**\n     * Folds long lines, useful for folding header lines (afterSpace=false) and\n     * flowed text (afterSpace=true)\n     *\n     * @param {String} str String to be folded\n     * @param {Number} [lineLength=76] Maximum length of a line\n     * @param {Boolean} afterSpace If true, leave a space in th end of a line\n     * @return {String} String with folded lines\n     */\n    foldLines: function (str, lineLength, afterSpace) {\n        str = (str || '').toString();\n        lineLength = lineLength || 76;\n\n        var pos = 0,\n            len = str.length,\n            result = '',\n            line, match;\n\n        while (pos < len) {\n            line = str.substr(pos, lineLength);\n            if (line.length < lineLength) {\n                result += line;\n                break;\n            }\n            if ((match = line.match(/^[^\\n\\r]*(\\r?\\n|\\r)/))) {\n                line = match[0];\n                result += line;\n                pos += line.length;\n                continue;\n            } else if ((match = line.match(/(\\s+)[^\\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {\n                line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)));\n            } else if ((match = str.substr(pos + line.length).match(/^[^\\s]+(\\s*)/))) {\n                line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0));\n            }\n\n            result += line;\n            pos += line.length;\n            if (pos < len) {\n                result += '\\r\\n';\n            }\n        }\n\n        return result;\n    }\n};\n\n/**\n * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n *\n * @param {String} str Mime encoded string to be split up\n * @param {Number} maxlen Maximum length of characters for one part (minimum 12)\n * @return {Array} Split string\n */\nfunction splitMimeEncodedString(str, maxlen) {\n    var curLine, match, chr, done,\n        lines = [];\n\n    // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n    maxlen = Math.max(maxlen || 0, 12);\n\n    while (str.length) {\n        curLine = str.substr(0, maxlen);\n\n        // move incomplete escaped char back to main\n        if ((match = curLine.match(/\\=[0-9A-F]?$/i))) {\n            curLine = curLine.substr(0, match.index);\n        }\n\n        done = false;\n        while (!done) {\n            done = true;\n            // check if not middle of a unicode char sequence\n            if ((match = str.substr(curLine.length).match(/^\\=([0-9A-F]{2})/i))) {\n                chr = parseInt(match[1], 16);\n                // invalid sequence, move one char back anc recheck\n                if (chr < 0xC2 && chr > 0x7F) {\n                    curLine = curLine.substr(0, curLine.length - 3);\n                    done = false;\n                }\n            }\n        }\n\n        if (curLine.length) {\n            lines.push(curLine);\n        }\n        str = str.substr(curLine.length);\n    }\n\n    return lines;\n}\n\nfunction encodeURICharComponent(chr) {\n    var i, len, ord;\n    var res = '';\n\n    ord = chr.charCodeAt(0).toString(16).toUpperCase();\n    if (ord.length % 2) {\n        ord = '0' + ord;\n    }\n    if (ord.length > 2) {\n        for (i = 0, len = ord.length / 2; i < len; i++) {\n            res += '%' + ord.substr(i, 2);\n        }\n    } else {\n        res += '%' + ord;\n    }\n\n    return res;\n}\n\nfunction safeEncodeURIComponent(str) {\n    str = (str || '').toString();\n\n    try {\n        // might throw if we try to encode invalid sequences, eg. partial emoji\n        str = encodeURIComponent(str);\n    } catch (E) {\n        // should never run\n        return str.replace(/[^\\x00-\\x1F *'()<>@,;:\\\\\"\\[\\]?=\\u007F-\\uFFFF]+/g, '');\n    }\n\n    // ensure chars that are not handled by encodeURICompent are converted as well\n    return str.replace(/[\\x00-\\x1F *'()<>@,;:\\\\\"\\[\\]?=\\u007F-\\uFFFF]/g, encodeURICharComponent);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}