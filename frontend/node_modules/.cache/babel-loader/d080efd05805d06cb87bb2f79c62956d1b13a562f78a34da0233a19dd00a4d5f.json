{"ast":null,"code":"'use strict';\n\nvar stream = require('stream');\nvar util = require('util');\nvar Transform = stream.Transform;\n\n// expose to the world\nmodule.exports = {\n  encode: encode,\n  decode: decode,\n  wrap: wrap,\n  Encoder: Encoder,\n  Decoder: Decoder\n};\n\n/**\n * Encodes a Buffer into a Quoted-Printable encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} Quoted-Printable encoded string\n */\nfunction encode(buffer) {\n  if (typeof buffer === 'string') {\n    buffer = new Buffer(buffer, 'utf-8');\n  }\n\n  // usable characters that do not need encoding\n  var ranges = [\n  // https://tools.ietf.org/html/rfc2045#section-6.7\n  [0x09],\n  // <TAB>\n  [0x0A],\n  // <LF>\n  [0x0D],\n  // <CR>\n  [0x20, 0x3C],\n  // <SP>!\"#$%&'()*+,-./0123456789:;\n  [0x3E, 0x7E] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n  ];\n  var result = '';\n  var ord;\n  for (var i = 0, len = buffer.length; i < len; i++) {\n    ord = buffer[i];\n    // if the char is in allowed range, then keep as is, unless it is a ws in the end of a line\n    if (checkRanges(ord, ranges) && !((ord === 0x20 || ord === 0x09) && (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i + 1] === 0x0d))) {\n      result += String.fromCharCode(ord);\n      continue;\n    }\n    result += '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase();\n  }\n  return result;\n}\n\n/**\n * Decodes a Quoted-Printable encoded string to a Buffer object\n *\n * @param {String} str Quoted-Printable encoded string\n * @returns {Buffer} Decoded value\n */\nfunction decode(str) {\n  str = (str || '').toString().\n  // remove invalid whitespace from the end of lines\n  replace(/[\\t ]+$/gm, '').\n  // remove soft line breaks\n  replace(/\\=(?:\\r?\\n|$)/g, '');\n  var encodedBytesCount = (str.match(/\\=[\\da-fA-F]{2}/g) || []).length,\n    bufferLength = str.length - encodedBytesCount * 2,\n    chr,\n    hex,\n    buffer = new Buffer(bufferLength),\n    bufferPos = 0;\n  for (var i = 0, len = str.length; i < len; i++) {\n    chr = str.charAt(i);\n    if (chr === '=' && (hex = str.substr(i + 1, 2)) && /[\\da-fA-F]{2}/.test(hex)) {\n      buffer[bufferPos++] = parseInt(hex, 16);\n      i += 2;\n      continue;\n    }\n    buffer[bufferPos++] = chr.charCodeAt(0);\n  }\n  return buffer;\n}\n\n/**\n * Adds soft line breaks to a Quoted-Printable string\n *\n * @param {String} str Quoted-Printable encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped Quoted-Printable encoded string\n */\nfunction wrap(str, lineLength) {\n  str = (str || '').toString();\n  lineLength = lineLength || 76;\n  if (str.length <= lineLength) {\n    return str;\n  }\n  var pos = 0,\n    len = str.length,\n    match,\n    code,\n    line,\n    lineMargin = Math.floor(lineLength / 3),\n    result = '';\n\n  // insert soft linebreaks where needed\n  while (pos < len) {\n    line = str.substr(pos, lineLength);\n    if (match = line.match(/\\r\\n/)) {\n      line = line.substr(0, match.index + match[0].length);\n      result += line;\n      pos += line.length;\n      continue;\n    }\n    if (line.substr(-1) === '\\n') {\n      // nothing to change here\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (match = line.substr(-lineMargin).match(/\\n.*?$/)) {\n      // truncate to nearest line break\n      line = line.substr(0, line.length - (match[0].length - 1));\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t\\.,!\\?][^ \\t\\.,!\\?]*$/))) {\n      // truncate to nearest space\n      line = line.substr(0, line.length - (match[0].length - 1));\n    } else {\n      if (line.match(/\\=[\\da-f]{0,2}$/i)) {\n        // push incomplete encoding sequences to the next line\n        if (match = line.match(/\\=[\\da-f]{0,1}$/i)) {\n          line = line.substr(0, line.length - match[0].length);\n        }\n\n        // ensure that utf-8 sequences are not split\n        while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/\\=[\\da-f]{2}$/ig))) {\n          code = parseInt(match[0].substr(1, 2), 16);\n          if (code < 128) {\n            break;\n          }\n          line = line.substr(0, line.length - 3);\n          if (code >= 0xC0) {\n            break;\n          }\n        }\n      }\n    }\n    if (pos + line.length < len && line.substr(-1) !== '\\n') {\n      if (line.length === lineLength && line.match(/\\=[\\da-f]{2}$/i)) {\n        line = line.substr(0, line.length - 3);\n      } else if (line.length === lineLength) {\n        line = line.substr(0, line.length - 1);\n      }\n      pos += line.length;\n      line += '=\\r\\n';\n    } else {\n      pos += line.length;\n    }\n    result += line;\n  }\n  return result;\n}\n\n/**\n * Helper function to check if a number is inside provided ranges\n *\n * @param {Number} nr Number to check for\n * @param {Array} ranges An Array of allowed values\n * @returns {Boolean} True if the value was found inside allowed ranges, false otherwise\n */\nfunction checkRanges(nr, ranges) {\n  for (var i = ranges.length - 1; i >= 0; i--) {\n    if (!ranges[i].length) {\n      continue;\n    }\n    if (ranges[i].length === 1 && nr === ranges[i][0]) {\n      return true;\n    }\n    if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Creates a transform stream for encoding data to Quoted-Printable encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping\n */\nfunction Encoder(options) {\n  // init Transform\n  this.options = options || {};\n  if (this.options.lineLength !== false) {\n    this.options.lineLength = this.options.lineLength || 76;\n  }\n  this._curLine = '';\n  this.inputBytes = 0;\n  this.outputBytes = 0;\n  Transform.call(this, this.options);\n}\nutil.inherits(Encoder, Transform);\nEncoder.prototype._transform = function (chunk, encoding, done) {\n  var qp,\n    _self = this;\n  if (encoding !== 'buffer') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  if (!chunk || !chunk.length) {\n    return done();\n  }\n  this.inputBytes += chunk.length;\n  if (this.options.lineLength) {\n    qp = this._curLine + encode(chunk);\n    qp = wrap(qp, this.options.lineLength);\n    qp = qp.replace(/(^|\\n)([^\\n]*)$/, function (match, lineBreak, lastLine) {\n      _self._curLine = lastLine;\n      return lineBreak;\n    });\n    if (qp) {\n      this.outputBytes += qp.length;\n      this.push(qp);\n    }\n  } else {\n    qp = encode(chunk);\n    this.outputBytes += qp.length;\n    this.push(qp, 'ascii');\n  }\n  done();\n};\nEncoder.prototype._flush = function (done) {\n  if (this._curLine) {\n    this.outputBytes += this._curLine.length;\n    this.push(this._curLine, 'ascii');\n  }\n  done();\n};\n\n/**\n * Creates a transform stream for decoding Quoted-Printable encoded strings\n *\n * @constructor\n * @param {Object} options Stream options\n */\nfunction Decoder(options) {\n  // init Transform\n  this.options = options || {};\n  this._curLine = '';\n  this.inputBytes = 0;\n  this.outputBytes = 0;\n  Transform.call(this, this.options);\n}\nutil.inherits(Decoder, Transform);\nDecoder.prototype._transform = function (chunk, encoding, done) {\n  var qp,\n    buf,\n    _self = this;\n  chunk = chunk.toString('ascii');\n  if (!chunk || !chunk.length) {\n    return done();\n  }\n  this.inputBytes += chunk.length;\n  qp = this._curLine + chunk;\n  this._curLine = '';\n  qp = qp.replace(/=[^\\n]?$/, function (lastLine) {\n    _self._curLine = lastLine;\n    return '';\n  });\n  if (qp) {\n    buf = decode(qp);\n    this.outputBytes += buf.length;\n    this.push(buf);\n  }\n  done();\n};\nDecoder.prototype._flush = function (done) {\n  var qp, buf;\n  if (this._curLine) {\n    buf = decode(this._curLine);\n    this.outputBytes += buf.length;\n    this.push(buf);\n  }\n  done();\n};","map":{"version":3,"names":["stream","require","util","Transform","module","exports","encode","decode","wrap","Encoder","Decoder","buffer","Buffer","ranges","result","ord","i","len","length","checkRanges","String","fromCharCode","toString","toUpperCase","str","replace","encodedBytesCount","match","bufferLength","chr","hex","bufferPos","charAt","substr","test","parseInt","charCodeAt","lineLength","pos","code","line","lineMargin","Math","floor","index","nr","options","_curLine","inputBytes","outputBytes","call","inherits","prototype","_transform","chunk","encoding","done","qp","_self","lineBreak","lastLine","push","_flush","buf"],"sources":["C:/Users/Admin/OneDrive/Desktop/Online Book Thrift Store/frontend/node_modules/libqp/lib/libqp.js"],"sourcesContent":["'use strict';\n\nvar stream = require('stream');\nvar util = require('util');\nvar Transform = stream.Transform;\n\n// expose to the world\nmodule.exports = {\n    encode: encode,\n    decode: decode,\n    wrap: wrap,\n    Encoder: Encoder,\n    Decoder: Decoder\n};\n\n/**\n * Encodes a Buffer into a Quoted-Printable encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} Quoted-Printable encoded string\n */\nfunction encode(buffer) {\n    if (typeof buffer === 'string') {\n        buffer = new Buffer(buffer, 'utf-8');\n    }\n\n    // usable characters that do not need encoding\n    var ranges = [\n        // https://tools.ietf.org/html/rfc2045#section-6.7\n        [0x09], // <TAB>\n        [0x0A], // <LF>\n        [0x0D], // <CR>\n        [0x20, 0x3C], // <SP>!\"#$%&'()*+,-./0123456789:;\n        [0x3E, 0x7E] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n    ];\n    var result = '';\n    var ord;\n\n    for (var i = 0, len = buffer.length; i < len; i++) {\n        ord = buffer[i];\n        // if the char is in allowed range, then keep as is, unless it is a ws in the end of a line\n        if (checkRanges(ord, ranges) && !((ord === 0x20 || ord === 0x09) && (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i + 1] === 0x0d))) {\n            result += String.fromCharCode(ord);\n            continue;\n        }\n        result += '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase();\n    }\n\n    return result;\n}\n\n/**\n * Decodes a Quoted-Printable encoded string to a Buffer object\n *\n * @param {String} str Quoted-Printable encoded string\n * @returns {Buffer} Decoded value\n */\nfunction decode(str) {\n    str = (str || '').toString().\n        // remove invalid whitespace from the end of lines\n    replace(/[\\t ]+$/gm, '').\n        // remove soft line breaks\n    replace(/\\=(?:\\r?\\n|$)/g, '');\n\n    var encodedBytesCount = (str.match(/\\=[\\da-fA-F]{2}/g) || []).length,\n        bufferLength = str.length - encodedBytesCount * 2,\n        chr, hex,\n        buffer = new Buffer(bufferLength),\n        bufferPos = 0;\n\n    for (var i = 0, len = str.length; i < len; i++) {\n        chr = str.charAt(i);\n        if (chr === '=' && (hex = str.substr(i + 1, 2)) && /[\\da-fA-F]{2}/.test(hex)) {\n            buffer[bufferPos++] = parseInt(hex, 16);\n            i += 2;\n            continue;\n        }\n        buffer[bufferPos++] = chr.charCodeAt(0);\n    }\n\n    return buffer;\n}\n\n/**\n * Adds soft line breaks to a Quoted-Printable string\n *\n * @param {String} str Quoted-Printable encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped Quoted-Printable encoded string\n */\nfunction wrap(str, lineLength) {\n    str = (str || '').toString();\n    lineLength = lineLength || 76;\n\n    if (str.length <= lineLength) {\n        return str;\n    }\n\n    var pos = 0,\n        len = str.length,\n        match, code, line,\n        lineMargin = Math.floor(lineLength / 3),\n        result = '';\n\n    // insert soft linebreaks where needed\n    while (pos < len) {\n        line = str.substr(pos, lineLength);\n        if ((match = line.match(/\\r\\n/))) {\n            line = line.substr(0, match.index + match[0].length);\n            result += line;\n            pos += line.length;\n            continue;\n        }\n\n        if (line.substr(-1) === '\\n') {\n            // nothing to change here\n            result += line;\n            pos += line.length;\n            continue;\n        } else if ((match = line.substr(-lineMargin).match(/\\n.*?$/))) {\n            // truncate to nearest line break\n            line = line.substr(0, line.length - (match[0].length - 1));\n            result += line;\n            pos += line.length;\n            continue;\n        } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t\\.,!\\?][^ \\t\\.,!\\?]*$/))) {\n            // truncate to nearest space\n            line = line.substr(0, line.length - (match[0].length - 1));\n        } else {\n            if (line.match(/\\=[\\da-f]{0,2}$/i)) {\n\n                // push incomplete encoding sequences to the next line\n                if ((match = line.match(/\\=[\\da-f]{0,1}$/i))) {\n                    line = line.substr(0, line.length - match[0].length);\n                }\n\n                // ensure that utf-8 sequences are not split\n                while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/\\=[\\da-f]{2}$/ig))) {\n                    code = parseInt(match[0].substr(1, 2), 16);\n                    if (code < 128) {\n                        break;\n                    }\n\n                    line = line.substr(0, line.length - 3);\n\n                    if (code >= 0xC0) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (pos + line.length < len && line.substr(-1) !== '\\n') {\n            if (line.length === lineLength && line.match(/\\=[\\da-f]{2}$/i)) {\n                line = line.substr(0, line.length - 3);\n            } else if (line.length === lineLength) {\n                line = line.substr(0, line.length - 1);\n            }\n            pos += line.length;\n            line += '=\\r\\n';\n        } else {\n            pos += line.length;\n        }\n\n        result += line;\n    }\n\n    return result;\n}\n\n/**\n * Helper function to check if a number is inside provided ranges\n *\n * @param {Number} nr Number to check for\n * @param {Array} ranges An Array of allowed values\n * @returns {Boolean} True if the value was found inside allowed ranges, false otherwise\n */\nfunction checkRanges(nr, ranges) {\n    for (var i = ranges.length - 1; i >= 0; i--) {\n        if (!ranges[i].length) {\n            continue;\n        }\n        if (ranges[i].length === 1 && nr === ranges[i][0]) {\n            return true;\n        }\n        if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Creates a transform stream for encoding data to Quoted-Printable encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping\n */\nfunction Encoder(options) {\n    // init Transform\n    this.options = options || {};\n\n    if (this.options.lineLength !== false) {\n        this.options.lineLength = this.options.lineLength || 76;\n    }\n\n    this._curLine = '';\n\n    this.inputBytes = 0;\n    this.outputBytes = 0;\n\n    Transform.call(this, this.options);\n}\nutil.inherits(Encoder, Transform);\n\nEncoder.prototype._transform = function(chunk, encoding, done) {\n    var qp, _self = this;\n\n    if (encoding !== 'buffer') {\n        chunk = new Buffer(chunk, encoding);\n    }\n\n    if (!chunk || !chunk.length) {\n        return done();\n    }\n\n    this.inputBytes += chunk.length;\n\n    if (this.options.lineLength) {\n        qp = this._curLine + encode(chunk);\n        qp = wrap(qp, this.options.lineLength);\n        qp = qp.replace(/(^|\\n)([^\\n]*)$/, function(match, lineBreak, lastLine) {\n            _self._curLine = lastLine;\n            return lineBreak;\n        });\n\n        if (qp) {\n            this.outputBytes += qp.length;\n            this.push(qp);\n        }\n\n    } else {\n        qp = encode(chunk);\n        this.outputBytes += qp.length;\n        this.push(qp, 'ascii');\n    }\n\n    done();\n};\n\nEncoder.prototype._flush = function(done) {\n    if (this._curLine) {\n        this.outputBytes += this._curLine.length;\n        this.push(this._curLine, 'ascii');\n    }\n    done();\n};\n\n/**\n * Creates a transform stream for decoding Quoted-Printable encoded strings\n *\n * @constructor\n * @param {Object} options Stream options\n */\nfunction Decoder(options) {\n    // init Transform\n    this.options = options || {};\n    this._curLine = '';\n\n    this.inputBytes = 0;\n    this.outputBytes = 0;\n\n    Transform.call(this, this.options);\n}\nutil.inherits(Decoder, Transform);\n\nDecoder.prototype._transform = function(chunk, encoding, done) {\n    var qp, buf, _self = this;\n\n    chunk = chunk.toString('ascii');\n\n    if (!chunk || !chunk.length) {\n        return done();\n    }\n\n    this.inputBytes += chunk.length;\n\n    qp = (this._curLine + chunk);\n    this._curLine = '';\n    qp = qp.replace(/=[^\\n]?$/, function(lastLine) {\n        _self._curLine = lastLine;\n        return '';\n    });\n\n    if (qp) {\n        buf = decode(qp);\n        this.outputBytes += buf.length;\n        this.push(buf);\n    }\n\n    done();\n};\n\nDecoder.prototype._flush = function(done) {\n    var qp, buf;\n    if (this._curLine) {\n        buf = decode(this._curLine);\n        this.outputBytes += buf.length;\n        this.push(buf);\n    }\n    done();\n};"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAC9B,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC1B,IAAIE,SAAS,GAAGH,MAAM,CAACG,SAAS;;AAEhC;AACAC,MAAM,CAACC,OAAO,GAAG;EACbC,MAAM,EAAEA,MAAM;EACdC,MAAM,EAAEA,MAAM;EACdC,IAAI,EAAEA,IAAI;EACVC,OAAO,EAAEA,OAAO;EAChBC,OAAO,EAAEA;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,SAASJ,MAAMA,CAACK,MAAM,EAAE;EACpB,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;IAC5BA,MAAM,GAAG,IAAIC,MAAM,CAACD,MAAM,EAAE,OAAO,CAAC;EACxC;;EAEA;EACA,IAAIE,MAAM,GAAG;EACT;EACA,CAAC,IAAI,CAAC;EAAE;EACR,CAAC,IAAI,CAAC;EAAE;EACR,CAAC,IAAI,CAAC;EAAE;EACR,CAAC,IAAI,EAAE,IAAI,CAAC;EAAE;EACd,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;EAAA,CAChB;EACD,IAAIC,MAAM,GAAG,EAAE;EACf,IAAIC,GAAG;EAEP,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGN,MAAM,CAACO,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;IAC/CD,GAAG,GAAGJ,MAAM,CAACK,CAAC,CAAC;IACf;IACA,IAAIG,WAAW,CAACJ,GAAG,EAAEF,MAAM,CAAC,IAAI,EAAE,CAACE,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAK,IAAI,MAAMC,CAAC,KAAKC,GAAG,GAAG,CAAC,IAAIN,MAAM,CAACK,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,IAAIL,MAAM,CAACK,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,EAAE;MACtIF,MAAM,IAAIM,MAAM,CAACC,YAAY,CAACN,GAAG,CAAC;MAClC;IACJ;IACAD,MAAM,IAAI,GAAG,IAAIC,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,EAAE,CAAC,GAAGA,GAAG,CAACO,QAAQ,CAAC,EAAE,CAAC,CAACC,WAAW,CAAC,CAAC;EAC5E;EAEA,OAAOT,MAAM;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASP,MAAMA,CAACiB,GAAG,EAAE;EACjBA,GAAG,GAAG,CAACA,GAAG,IAAI,EAAE,EAAEF,QAAQ,CAAC,CAAC;EACxB;EACJG,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC;EACpB;EACJA,OAAO,CAAC,gBAAgB,EAAE,EAAE,CAAC;EAE7B,IAAIC,iBAAiB,GAAG,CAACF,GAAG,CAACG,KAAK,CAAC,kBAAkB,CAAC,IAAI,EAAE,EAAET,MAAM;IAChEU,YAAY,GAAGJ,GAAG,CAACN,MAAM,GAAGQ,iBAAiB,GAAG,CAAC;IACjDG,GAAG;IAAEC,GAAG;IACRnB,MAAM,GAAG,IAAIC,MAAM,CAACgB,YAAY,CAAC;IACjCG,SAAS,GAAG,CAAC;EAEjB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGO,GAAG,CAACN,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;IAC5Ca,GAAG,GAAGL,GAAG,CAACQ,MAAM,CAAChB,CAAC,CAAC;IACnB,IAAIa,GAAG,KAAK,GAAG,KAAKC,GAAG,GAAGN,GAAG,CAACS,MAAM,CAACjB,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,eAAe,CAACkB,IAAI,CAACJ,GAAG,CAAC,EAAE;MAC1EnB,MAAM,CAACoB,SAAS,EAAE,CAAC,GAAGI,QAAQ,CAACL,GAAG,EAAE,EAAE,CAAC;MACvCd,CAAC,IAAI,CAAC;MACN;IACJ;IACAL,MAAM,CAACoB,SAAS,EAAE,CAAC,GAAGF,GAAG,CAACO,UAAU,CAAC,CAAC,CAAC;EAC3C;EAEA,OAAOzB,MAAM;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASH,IAAIA,CAACgB,GAAG,EAAEa,UAAU,EAAE;EAC3Bb,GAAG,GAAG,CAACA,GAAG,IAAI,EAAE,EAAEF,QAAQ,CAAC,CAAC;EAC5Be,UAAU,GAAGA,UAAU,IAAI,EAAE;EAE7B,IAAIb,GAAG,CAACN,MAAM,IAAImB,UAAU,EAAE;IAC1B,OAAOb,GAAG;EACd;EAEA,IAAIc,GAAG,GAAG,CAAC;IACPrB,GAAG,GAAGO,GAAG,CAACN,MAAM;IAChBS,KAAK;IAAEY,IAAI;IAAEC,IAAI;IACjBC,UAAU,GAAGC,IAAI,CAACC,KAAK,CAACN,UAAU,GAAG,CAAC,CAAC;IACvCvB,MAAM,GAAG,EAAE;;EAEf;EACA,OAAOwB,GAAG,GAAGrB,GAAG,EAAE;IACduB,IAAI,GAAGhB,GAAG,CAACS,MAAM,CAACK,GAAG,EAAED,UAAU,CAAC;IAClC,IAAKV,KAAK,GAAGa,IAAI,CAACb,KAAK,CAAC,MAAM,CAAC,EAAG;MAC9Ba,IAAI,GAAGA,IAAI,CAACP,MAAM,CAAC,CAAC,EAAEN,KAAK,CAACiB,KAAK,GAAGjB,KAAK,CAAC,CAAC,CAAC,CAACT,MAAM,CAAC;MACpDJ,MAAM,IAAI0B,IAAI;MACdF,GAAG,IAAIE,IAAI,CAACtB,MAAM;MAClB;IACJ;IAEA,IAAIsB,IAAI,CAACP,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;MAC1B;MACAnB,MAAM,IAAI0B,IAAI;MACdF,GAAG,IAAIE,IAAI,CAACtB,MAAM;MAClB;IACJ,CAAC,MAAM,IAAKS,KAAK,GAAGa,IAAI,CAACP,MAAM,CAAC,CAACQ,UAAU,CAAC,CAACd,KAAK,CAAC,QAAQ,CAAC,EAAG;MAC3D;MACAa,IAAI,GAAGA,IAAI,CAACP,MAAM,CAAC,CAAC,EAAEO,IAAI,CAACtB,MAAM,IAAIS,KAAK,CAAC,CAAC,CAAC,CAACT,MAAM,GAAG,CAAC,CAAC,CAAC;MAC1DJ,MAAM,IAAI0B,IAAI;MACdF,GAAG,IAAIE,IAAI,CAACtB,MAAM;MAClB;IACJ,CAAC,MAAM,IAAIsB,IAAI,CAACtB,MAAM,GAAGmB,UAAU,GAAGI,UAAU,KAAKd,KAAK,GAAGa,IAAI,CAACP,MAAM,CAAC,CAACQ,UAAU,CAAC,CAACd,KAAK,CAAC,2BAA2B,CAAC,CAAC,EAAE;MACvH;MACAa,IAAI,GAAGA,IAAI,CAACP,MAAM,CAAC,CAAC,EAAEO,IAAI,CAACtB,MAAM,IAAIS,KAAK,CAAC,CAAC,CAAC,CAACT,MAAM,GAAG,CAAC,CAAC,CAAC;IAC9D,CAAC,MAAM;MACH,IAAIsB,IAAI,CAACb,KAAK,CAAC,kBAAkB,CAAC,EAAE;QAEhC;QACA,IAAKA,KAAK,GAAGa,IAAI,CAACb,KAAK,CAAC,kBAAkB,CAAC,EAAG;UAC1Ca,IAAI,GAAGA,IAAI,CAACP,MAAM,CAAC,CAAC,EAAEO,IAAI,CAACtB,MAAM,GAAGS,KAAK,CAAC,CAAC,CAAC,CAACT,MAAM,CAAC;QACxD;;QAEA;QACA,OAAOsB,IAAI,CAACtB,MAAM,GAAG,CAAC,IAAIsB,IAAI,CAACtB,MAAM,GAAGD,GAAG,GAAGqB,GAAG,IAAI,CAACE,IAAI,CAACb,KAAK,CAAC,yBAAyB,CAAC,KAAKA,KAAK,GAAGa,IAAI,CAACb,KAAK,CAAC,iBAAiB,CAAC,CAAC,EAAE;UACpIY,IAAI,GAAGJ,QAAQ,CAACR,KAAK,CAAC,CAAC,CAAC,CAACM,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC;UAC1C,IAAIM,IAAI,GAAG,GAAG,EAAE;YACZ;UACJ;UAEAC,IAAI,GAAGA,IAAI,CAACP,MAAM,CAAC,CAAC,EAAEO,IAAI,CAACtB,MAAM,GAAG,CAAC,CAAC;UAEtC,IAAIqB,IAAI,IAAI,IAAI,EAAE;YACd;UACJ;QACJ;MACJ;IACJ;IAEA,IAAID,GAAG,GAAGE,IAAI,CAACtB,MAAM,GAAGD,GAAG,IAAIuB,IAAI,CAACP,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;MACrD,IAAIO,IAAI,CAACtB,MAAM,KAAKmB,UAAU,IAAIG,IAAI,CAACb,KAAK,CAAC,gBAAgB,CAAC,EAAE;QAC5Da,IAAI,GAAGA,IAAI,CAACP,MAAM,CAAC,CAAC,EAAEO,IAAI,CAACtB,MAAM,GAAG,CAAC,CAAC;MAC1C,CAAC,MAAM,IAAIsB,IAAI,CAACtB,MAAM,KAAKmB,UAAU,EAAE;QACnCG,IAAI,GAAGA,IAAI,CAACP,MAAM,CAAC,CAAC,EAAEO,IAAI,CAACtB,MAAM,GAAG,CAAC,CAAC;MAC1C;MACAoB,GAAG,IAAIE,IAAI,CAACtB,MAAM;MAClBsB,IAAI,IAAI,OAAO;IACnB,CAAC,MAAM;MACHF,GAAG,IAAIE,IAAI,CAACtB,MAAM;IACtB;IAEAJ,MAAM,IAAI0B,IAAI;EAClB;EAEA,OAAO1B,MAAM;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,WAAWA,CAAC0B,EAAE,EAAEhC,MAAM,EAAE;EAC7B,KAAK,IAAIG,CAAC,GAAGH,MAAM,CAACK,MAAM,GAAG,CAAC,EAAEF,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IACzC,IAAI,CAACH,MAAM,CAACG,CAAC,CAAC,CAACE,MAAM,EAAE;MACnB;IACJ;IACA,IAAIL,MAAM,CAACG,CAAC,CAAC,CAACE,MAAM,KAAK,CAAC,IAAI2B,EAAE,KAAKhC,MAAM,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;MAC/C,OAAO,IAAI;IACf;IACA,IAAIH,MAAM,CAACG,CAAC,CAAC,CAACE,MAAM,KAAK,CAAC,IAAI2B,EAAE,IAAIhC,MAAM,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI6B,EAAE,IAAIhC,MAAM,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;MACpE,OAAO,IAAI;IACf;EACJ;EACA,OAAO,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASP,OAAOA,CAACqC,OAAO,EAAE;EACtB;EACA,IAAI,CAACA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EAE5B,IAAI,IAAI,CAACA,OAAO,CAACT,UAAU,KAAK,KAAK,EAAE;IACnC,IAAI,CAACS,OAAO,CAACT,UAAU,GAAG,IAAI,CAACS,OAAO,CAACT,UAAU,IAAI,EAAE;EAC3D;EAEA,IAAI,CAACU,QAAQ,GAAG,EAAE;EAElB,IAAI,CAACC,UAAU,GAAG,CAAC;EACnB,IAAI,CAACC,WAAW,GAAG,CAAC;EAEpB9C,SAAS,CAAC+C,IAAI,CAAC,IAAI,EAAE,IAAI,CAACJ,OAAO,CAAC;AACtC;AACA5C,IAAI,CAACiD,QAAQ,CAAC1C,OAAO,EAAEN,SAAS,CAAC;AAEjCM,OAAO,CAAC2C,SAAS,CAACC,UAAU,GAAG,UAASC,KAAK,EAAEC,QAAQ,EAAEC,IAAI,EAAE;EAC3D,IAAIC,EAAE;IAAEC,KAAK,GAAG,IAAI;EAEpB,IAAIH,QAAQ,KAAK,QAAQ,EAAE;IACvBD,KAAK,GAAG,IAAI1C,MAAM,CAAC0C,KAAK,EAAEC,QAAQ,CAAC;EACvC;EAEA,IAAI,CAACD,KAAK,IAAI,CAACA,KAAK,CAACpC,MAAM,EAAE;IACzB,OAAOsC,IAAI,CAAC,CAAC;EACjB;EAEA,IAAI,CAACR,UAAU,IAAIM,KAAK,CAACpC,MAAM;EAE/B,IAAI,IAAI,CAAC4B,OAAO,CAACT,UAAU,EAAE;IACzBoB,EAAE,GAAG,IAAI,CAACV,QAAQ,GAAGzC,MAAM,CAACgD,KAAK,CAAC;IAClCG,EAAE,GAAGjD,IAAI,CAACiD,EAAE,EAAE,IAAI,CAACX,OAAO,CAACT,UAAU,CAAC;IACtCoB,EAAE,GAAGA,EAAE,CAAChC,OAAO,CAAC,iBAAiB,EAAE,UAASE,KAAK,EAAEgC,SAAS,EAAEC,QAAQ,EAAE;MACpEF,KAAK,CAACX,QAAQ,GAAGa,QAAQ;MACzB,OAAOD,SAAS;IACpB,CAAC,CAAC;IAEF,IAAIF,EAAE,EAAE;MACJ,IAAI,CAACR,WAAW,IAAIQ,EAAE,CAACvC,MAAM;MAC7B,IAAI,CAAC2C,IAAI,CAACJ,EAAE,CAAC;IACjB;EAEJ,CAAC,MAAM;IACHA,EAAE,GAAGnD,MAAM,CAACgD,KAAK,CAAC;IAClB,IAAI,CAACL,WAAW,IAAIQ,EAAE,CAACvC,MAAM;IAC7B,IAAI,CAAC2C,IAAI,CAACJ,EAAE,EAAE,OAAO,CAAC;EAC1B;EAEAD,IAAI,CAAC,CAAC;AACV,CAAC;AAED/C,OAAO,CAAC2C,SAAS,CAACU,MAAM,GAAG,UAASN,IAAI,EAAE;EACtC,IAAI,IAAI,CAACT,QAAQ,EAAE;IACf,IAAI,CAACE,WAAW,IAAI,IAAI,CAACF,QAAQ,CAAC7B,MAAM;IACxC,IAAI,CAAC2C,IAAI,CAAC,IAAI,CAACd,QAAQ,EAAE,OAAO,CAAC;EACrC;EACAS,IAAI,CAAC,CAAC;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,SAAS9C,OAAOA,CAACoC,OAAO,EAAE;EACtB;EACA,IAAI,CAACA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EAC5B,IAAI,CAACC,QAAQ,GAAG,EAAE;EAElB,IAAI,CAACC,UAAU,GAAG,CAAC;EACnB,IAAI,CAACC,WAAW,GAAG,CAAC;EAEpB9C,SAAS,CAAC+C,IAAI,CAAC,IAAI,EAAE,IAAI,CAACJ,OAAO,CAAC;AACtC;AACA5C,IAAI,CAACiD,QAAQ,CAACzC,OAAO,EAAEP,SAAS,CAAC;AAEjCO,OAAO,CAAC0C,SAAS,CAACC,UAAU,GAAG,UAASC,KAAK,EAAEC,QAAQ,EAAEC,IAAI,EAAE;EAC3D,IAAIC,EAAE;IAAEM,GAAG;IAAEL,KAAK,GAAG,IAAI;EAEzBJ,KAAK,GAAGA,KAAK,CAAChC,QAAQ,CAAC,OAAO,CAAC;EAE/B,IAAI,CAACgC,KAAK,IAAI,CAACA,KAAK,CAACpC,MAAM,EAAE;IACzB,OAAOsC,IAAI,CAAC,CAAC;EACjB;EAEA,IAAI,CAACR,UAAU,IAAIM,KAAK,CAACpC,MAAM;EAE/BuC,EAAE,GAAI,IAAI,CAACV,QAAQ,GAAGO,KAAM;EAC5B,IAAI,CAACP,QAAQ,GAAG,EAAE;EAClBU,EAAE,GAAGA,EAAE,CAAChC,OAAO,CAAC,UAAU,EAAE,UAASmC,QAAQ,EAAE;IAC3CF,KAAK,CAACX,QAAQ,GAAGa,QAAQ;IACzB,OAAO,EAAE;EACb,CAAC,CAAC;EAEF,IAAIH,EAAE,EAAE;IACJM,GAAG,GAAGxD,MAAM,CAACkD,EAAE,CAAC;IAChB,IAAI,CAACR,WAAW,IAAIc,GAAG,CAAC7C,MAAM;IAC9B,IAAI,CAAC2C,IAAI,CAACE,GAAG,CAAC;EAClB;EAEAP,IAAI,CAAC,CAAC;AACV,CAAC;AAED9C,OAAO,CAAC0C,SAAS,CAACU,MAAM,GAAG,UAASN,IAAI,EAAE;EACtC,IAAIC,EAAE,EAAEM,GAAG;EACX,IAAI,IAAI,CAAChB,QAAQ,EAAE;IACfgB,GAAG,GAAGxD,MAAM,CAAC,IAAI,CAACwC,QAAQ,CAAC;IAC3B,IAAI,CAACE,WAAW,IAAIc,GAAG,CAAC7C,MAAM;IAC9B,IAAI,CAAC2C,IAAI,CAACE,GAAG,CAAC;EAClB;EACAP,IAAI,CAAC,CAAC;AACV,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}