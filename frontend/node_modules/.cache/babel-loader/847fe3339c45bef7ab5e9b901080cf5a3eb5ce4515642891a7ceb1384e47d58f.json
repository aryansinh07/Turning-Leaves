{"ast":null,"code":"\"use strict\";\n\n// == Extend Node primitives to use iconv-lite =================================\nmodule.exports = function (iconv) {\n  var original = undefined; // Place to keep original methods.\n\n  // Node authors rewrote Buffer internals to make it compatible with\n  // Uint8Array and we cannot patch key functions since then.\n  iconv.supportsNodeEncodingsExtension = !(new Buffer(0) instanceof Uint8Array);\n  iconv.extendNodeEncodings = function extendNodeEncodings() {\n    if (original) return;\n    original = {};\n    if (!iconv.supportsNodeEncodingsExtension) {\n      console.error(\"ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node\");\n      console.error(\"See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility\");\n      return;\n    }\n    var nodeNativeEncodings = {\n      'hex': true,\n      'utf8': true,\n      'utf-8': true,\n      'ascii': true,\n      'binary': true,\n      'base64': true,\n      'ucs2': true,\n      'ucs-2': true,\n      'utf16le': true,\n      'utf-16le': true\n    };\n    Buffer.isNativeEncoding = function (enc) {\n      return enc && nodeNativeEncodings[enc.toLowerCase()];\n    };\n\n    // -- SlowBuffer -----------------------------------------------------------\n    var SlowBuffer = require('buffer').SlowBuffer;\n    original.SlowBufferToString = SlowBuffer.prototype.toString;\n    SlowBuffer.prototype.toString = function (encoding, start, end) {\n      encoding = String(encoding || 'utf8').toLowerCase();\n\n      // Use native conversion when possible\n      if (Buffer.isNativeEncoding(encoding)) return original.SlowBufferToString.call(this, encoding, start, end);\n\n      // Otherwise, use our decoding method.\n      if (typeof start == 'undefined') start = 0;\n      if (typeof end == 'undefined') end = this.length;\n      return iconv.decode(this.slice(start, end), encoding);\n    };\n    original.SlowBufferWrite = SlowBuffer.prototype.write;\n    SlowBuffer.prototype.write = function (string, offset, length, encoding) {\n      // Support both (string, offset, length, encoding)\n      // and the legacy (string, encoding, offset, length)\n      if (isFinite(offset)) {\n        if (!isFinite(length)) {\n          encoding = length;\n          length = undefined;\n        }\n      } else {\n        // legacy\n        var swap = encoding;\n        encoding = offset;\n        offset = length;\n        length = swap;\n      }\n      offset = +offset || 0;\n      var remaining = this.length - offset;\n      if (!length) {\n        length = remaining;\n      } else {\n        length = +length;\n        if (length > remaining) {\n          length = remaining;\n        }\n      }\n      encoding = String(encoding || 'utf8').toLowerCase();\n\n      // Use native conversion when possible\n      if (Buffer.isNativeEncoding(encoding)) return original.SlowBufferWrite.call(this, string, offset, length, encoding);\n      if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');\n\n      // Otherwise, use our encoding method.\n      var buf = iconv.encode(string, encoding);\n      if (buf.length < length) length = buf.length;\n      buf.copy(this, offset, 0, length);\n      return length;\n    };\n\n    // -- Buffer ---------------------------------------------------------------\n\n    original.BufferIsEncoding = Buffer.isEncoding;\n    Buffer.isEncoding = function (encoding) {\n      return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);\n    };\n    original.BufferByteLength = Buffer.byteLength;\n    Buffer.byteLength = SlowBuffer.byteLength = function (str, encoding) {\n      encoding = String(encoding || 'utf8').toLowerCase();\n\n      // Use native conversion when possible\n      if (Buffer.isNativeEncoding(encoding)) return original.BufferByteLength.call(this, str, encoding);\n\n      // Slow, I know, but we don't have a better way yet.\n      return iconv.encode(str, encoding).length;\n    };\n    original.BufferToString = Buffer.prototype.toString;\n    Buffer.prototype.toString = function (encoding, start, end) {\n      encoding = String(encoding || 'utf8').toLowerCase();\n\n      // Use native conversion when possible\n      if (Buffer.isNativeEncoding(encoding)) return original.BufferToString.call(this, encoding, start, end);\n\n      // Otherwise, use our decoding method.\n      if (typeof start == 'undefined') start = 0;\n      if (typeof end == 'undefined') end = this.length;\n      return iconv.decode(this.slice(start, end), encoding);\n    };\n    original.BufferWrite = Buffer.prototype.write;\n    Buffer.prototype.write = function (string, offset, length, encoding) {\n      var _offset = offset,\n        _length = length,\n        _encoding = encoding;\n      // Support both (string, offset, length, encoding)\n      // and the legacy (string, encoding, offset, length)\n      if (isFinite(offset)) {\n        if (!isFinite(length)) {\n          encoding = length;\n          length = undefined;\n        }\n      } else {\n        // legacy\n        var swap = encoding;\n        encoding = offset;\n        offset = length;\n        length = swap;\n      }\n      encoding = String(encoding || 'utf8').toLowerCase();\n\n      // Use native conversion when possible\n      if (Buffer.isNativeEncoding(encoding)) return original.BufferWrite.call(this, string, _offset, _length, _encoding);\n      offset = +offset || 0;\n      var remaining = this.length - offset;\n      if (!length) {\n        length = remaining;\n      } else {\n        length = +length;\n        if (length > remaining) {\n          length = remaining;\n        }\n      }\n      if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');\n\n      // Otherwise, use our encoding method.\n      var buf = iconv.encode(string, encoding);\n      if (buf.length < length) length = buf.length;\n      buf.copy(this, offset, 0, length);\n      return length;\n\n      // TODO: Set _charsWritten.\n    };\n\n    // -- Readable -------------------------------------------------------------\n    if (iconv.supportsStreams) {\n      var Readable = require('stream').Readable;\n      original.ReadableSetEncoding = Readable.prototype.setEncoding;\n      Readable.prototype.setEncoding = function setEncoding(enc, options) {\n        // Use our own decoder, it has the same interface.\n        // We cannot use original function as it doesn't handle BOM-s.\n        this._readableState.decoder = iconv.getDecoder(enc, options);\n        this._readableState.encoding = enc;\n      };\n      Readable.prototype.collect = iconv._collect;\n    }\n  };\n\n  // Remove iconv-lite Node primitive extensions.\n  iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {\n    if (!iconv.supportsNodeEncodingsExtension) return;\n    if (!original) throw new Error(\"require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.\");\n    delete Buffer.isNativeEncoding;\n    var SlowBuffer = require('buffer').SlowBuffer;\n    SlowBuffer.prototype.toString = original.SlowBufferToString;\n    SlowBuffer.prototype.write = original.SlowBufferWrite;\n    Buffer.isEncoding = original.BufferIsEncoding;\n    Buffer.byteLength = original.BufferByteLength;\n    Buffer.prototype.toString = original.BufferToString;\n    Buffer.prototype.write = original.BufferWrite;\n    if (iconv.supportsStreams) {\n      var Readable = require('stream').Readable;\n      Readable.prototype.setEncoding = original.ReadableSetEncoding;\n      delete Readable.prototype.collect;\n    }\n    original = undefined;\n  };\n};","map":{"version":3,"names":["module","exports","iconv","original","undefined","supportsNodeEncodingsExtension","Buffer","Uint8Array","extendNodeEncodings","console","error","nodeNativeEncodings","isNativeEncoding","enc","toLowerCase","SlowBuffer","require","SlowBufferToString","prototype","toString","encoding","start","end","String","call","length","decode","slice","SlowBufferWrite","write","string","offset","isFinite","swap","remaining","RangeError","buf","encode","copy","BufferIsEncoding","isEncoding","encodingExists","BufferByteLength","byteLength","str","BufferToString","BufferWrite","_offset","_length","_encoding","supportsStreams","Readable","ReadableSetEncoding","setEncoding","options","_readableState","decoder","getDecoder","collect","_collect","undoExtendNodeEncodings","Error"],"sources":["C:/Users/Admin/OneDrive/Desktop/Online Book Thrift Store/frontend/node_modules/libmime/node_modules/iconv-lite/lib/extend-node.js"],"sourcesContent":["\"use strict\"\n\n// == Extend Node primitives to use iconv-lite =================================\n\nmodule.exports = function (iconv) {\n    var original = undefined; // Place to keep original methods.\n\n    // Node authors rewrote Buffer internals to make it compatible with\n    // Uint8Array and we cannot patch key functions since then.\n    iconv.supportsNodeEncodingsExtension = !(new Buffer(0) instanceof Uint8Array);\n\n    iconv.extendNodeEncodings = function extendNodeEncodings() {\n        if (original) return;\n        original = {};\n\n        if (!iconv.supportsNodeEncodingsExtension) {\n            console.error(\"ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node\");\n            console.error(\"See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility\");\n            return;\n        }\n\n        var nodeNativeEncodings = {\n            'hex': true, 'utf8': true, 'utf-8': true, 'ascii': true, 'binary': true, \n            'base64': true, 'ucs2': true, 'ucs-2': true, 'utf16le': true, 'utf-16le': true,\n        };\n\n        Buffer.isNativeEncoding = function(enc) {\n            return enc && nodeNativeEncodings[enc.toLowerCase()];\n        }\n\n        // -- SlowBuffer -----------------------------------------------------------\n        var SlowBuffer = require('buffer').SlowBuffer;\n\n        original.SlowBufferToString = SlowBuffer.prototype.toString;\n        SlowBuffer.prototype.toString = function(encoding, start, end) {\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.SlowBufferToString.call(this, encoding, start, end);\n\n            // Otherwise, use our decoding method.\n            if (typeof start == 'undefined') start = 0;\n            if (typeof end == 'undefined') end = this.length;\n            return iconv.decode(this.slice(start, end), encoding);\n        }\n\n        original.SlowBufferWrite = SlowBuffer.prototype.write;\n        SlowBuffer.prototype.write = function(string, offset, length, encoding) {\n            // Support both (string, offset, length, encoding)\n            // and the legacy (string, encoding, offset, length)\n            if (isFinite(offset)) {\n                if (!isFinite(length)) {\n                    encoding = length;\n                    length = undefined;\n                }\n            } else {  // legacy\n                var swap = encoding;\n                encoding = offset;\n                offset = length;\n                length = swap;\n            }\n\n            offset = +offset || 0;\n            var remaining = this.length - offset;\n            if (!length) {\n                length = remaining;\n            } else {\n                length = +length;\n                if (length > remaining) {\n                    length = remaining;\n                }\n            }\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.SlowBufferWrite.call(this, string, offset, length, encoding);\n\n            if (string.length > 0 && (length < 0 || offset < 0))\n                throw new RangeError('attempt to write beyond buffer bounds');\n\n            // Otherwise, use our encoding method.\n            var buf = iconv.encode(string, encoding);\n            if (buf.length < length) length = buf.length;\n            buf.copy(this, offset, 0, length);\n            return length;\n        }\n\n        // -- Buffer ---------------------------------------------------------------\n\n        original.BufferIsEncoding = Buffer.isEncoding;\n        Buffer.isEncoding = function(encoding) {\n            return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);\n        }\n\n        original.BufferByteLength = Buffer.byteLength;\n        Buffer.byteLength = SlowBuffer.byteLength = function(str, encoding) {\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.BufferByteLength.call(this, str, encoding);\n\n            // Slow, I know, but we don't have a better way yet.\n            return iconv.encode(str, encoding).length;\n        }\n\n        original.BufferToString = Buffer.prototype.toString;\n        Buffer.prototype.toString = function(encoding, start, end) {\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.BufferToString.call(this, encoding, start, end);\n\n            // Otherwise, use our decoding method.\n            if (typeof start == 'undefined') start = 0;\n            if (typeof end == 'undefined') end = this.length;\n            return iconv.decode(this.slice(start, end), encoding);\n        }\n\n        original.BufferWrite = Buffer.prototype.write;\n        Buffer.prototype.write = function(string, offset, length, encoding) {\n            var _offset = offset, _length = length, _encoding = encoding;\n            // Support both (string, offset, length, encoding)\n            // and the legacy (string, encoding, offset, length)\n            if (isFinite(offset)) {\n                if (!isFinite(length)) {\n                    encoding = length;\n                    length = undefined;\n                }\n            } else {  // legacy\n                var swap = encoding;\n                encoding = offset;\n                offset = length;\n                length = swap;\n            }\n\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.BufferWrite.call(this, string, _offset, _length, _encoding);\n\n            offset = +offset || 0;\n            var remaining = this.length - offset;\n            if (!length) {\n                length = remaining;\n            } else {\n                length = +length;\n                if (length > remaining) {\n                    length = remaining;\n                }\n            }\n\n            if (string.length > 0 && (length < 0 || offset < 0))\n                throw new RangeError('attempt to write beyond buffer bounds');\n\n            // Otherwise, use our encoding method.\n            var buf = iconv.encode(string, encoding);\n            if (buf.length < length) length = buf.length;\n            buf.copy(this, offset, 0, length);\n            return length;\n\n            // TODO: Set _charsWritten.\n        }\n\n\n        // -- Readable -------------------------------------------------------------\n        if (iconv.supportsStreams) {\n            var Readable = require('stream').Readable;\n\n            original.ReadableSetEncoding = Readable.prototype.setEncoding;\n            Readable.prototype.setEncoding = function setEncoding(enc, options) {\n                // Use our own decoder, it has the same interface.\n                // We cannot use original function as it doesn't handle BOM-s.\n                this._readableState.decoder = iconv.getDecoder(enc, options);\n                this._readableState.encoding = enc;\n            }\n\n            Readable.prototype.collect = iconv._collect;\n        }\n    }\n\n    // Remove iconv-lite Node primitive extensions.\n    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {\n        if (!iconv.supportsNodeEncodingsExtension)\n            return;\n        if (!original)\n            throw new Error(\"require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.\")\n\n        delete Buffer.isNativeEncoding;\n\n        var SlowBuffer = require('buffer').SlowBuffer;\n\n        SlowBuffer.prototype.toString = original.SlowBufferToString;\n        SlowBuffer.prototype.write = original.SlowBufferWrite;\n\n        Buffer.isEncoding = original.BufferIsEncoding;\n        Buffer.byteLength = original.BufferByteLength;\n        Buffer.prototype.toString = original.BufferToString;\n        Buffer.prototype.write = original.BufferWrite;\n\n        if (iconv.supportsStreams) {\n            var Readable = require('stream').Readable;\n\n            Readable.prototype.setEncoding = original.ReadableSetEncoding;\n            delete Readable.prototype.collect;\n        }\n\n        original = undefined;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}