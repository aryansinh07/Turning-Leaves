{"ast":null,"code":"'use strict';\n\nvar libmime = require('libmime');\nvar libqp = require('libqp');\nvar libbase64 = require('libbase64');\nvar punycode = require('punycode');\nvar addressparser = require('addressparser');\nvar stream = require('stream');\nvar PassThrough = stream.PassThrough;\nvar fs = require('fs');\nvar fetch = require('nodemailer-fetch');\nvar crypto = require('crypto');\nvar os = require('os');\nmodule.exports = MimeNode;\n\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\nfunction MimeNode(contentType, options) {\n  this.nodeCounter = 0;\n  options = options || {};\n\n  /**\n   * shared part of the unique multipart boundary\n   */\n  this.baseBoundary = options.baseBoundary || Date.now().toString() + Math.random();\n  this.boundaryPrefix = options.boundaryPrefix || '----sinikael';\n  this.disableFileAccess = !!options.disableFileAccess;\n  this.disableUrlAccess = !!options.disableUrlAccess;\n\n  /**\n   * If date headers is missing and current node is the root, this value is used instead\n   */\n  this.date = new Date();\n\n  /**\n   * Root node for current mime tree\n   */\n  this.rootNode = options.rootNode || this;\n\n  /**\n   * If true include Bcc in generated headers (if available)\n   */\n  this.keepBcc = !!options.keepBcc;\n\n  /**\n   * If filename is specified but contentType is not (probably an attachment)\n   * detect the content type from filename extension\n   */\n  if (options.filename) {\n    /**\n     * Filename for this node. Useful with attachments\n     */\n    this.filename = options.filename;\n    if (!contentType) {\n      contentType = libmime.detectMimeType(this.filename.split('.').pop());\n    }\n  }\n\n  /**\n   * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n   */\n  this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n\n  /**\n   * Immediate parent for this node (or undefined if not set)\n   */\n  this.parentNode = options.parentNode;\n\n  /**\n   * Hostname for default message-id values\n   */\n  this.hostname = options.hostname;\n\n  /**\n   * An array for possible child nodes\n   */\n  this.childNodes = [];\n\n  /**\n   * Used for generating unique boundaries (prepended to the shared base)\n   */\n  this._nodeId = ++this.rootNode.nodeCounter;\n\n  /**\n   * A list of header values for this node in the form of [{key:'', value:''}]\n   */\n  this._headers = [];\n\n  /**\n   * True if the content only uses ASCII printable characters\n   * @type {Boolean}\n   */\n  this._isPlainText = false;\n\n  /**\n   * True if the content is plain text but has longer lines than allowed\n   * @type {Boolean}\n   */\n  this._hasLongLines = false;\n\n  /**\n   * If set, use instead this value for envelopes instead of generating one\n   * @type {Boolean}\n   */\n  this._envelope = false;\n\n  /**\n   * If set then use this value as the stream content instead of building it\n   * @type {String|Buffer|Stream}\n   */\n  this._raw = false;\n\n  /**\n   * Additional transform streams that the message will be piped before\n   * exposing by createReadStream\n   * @type {Array}\n   */\n  this._transforms = [];\n\n  /**\n   * If content type is set (or derived from the filename) add it to headers\n   */\n  if (contentType) {\n    this.setHeader('Content-Type', contentType);\n  }\n}\n\n/////// PUBLIC METHODS\n\n/**\n * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n *\n * @param {String} [contentType] Optional content type\n * @param {Object} [options] Optional options object\n * @return {Object} Created node object\n */\nMimeNode.prototype.createChild = function (contentType, options) {\n  if (!options && typeof contentType === 'object') {\n    options = contentType;\n    contentType = undefined;\n  }\n  var node = new MimeNode(contentType, options);\n  this.appendChild(node);\n  return node;\n};\n\n/**\n * Appends an existing node to the mime tree. Removes the node from an existing\n * tree if needed\n *\n * @param {Object} childNode node to be appended\n * @return {Object} Appended node object\n */\nMimeNode.prototype.appendChild = function (childNode) {\n  if (childNode.rootNode !== this.rootNode) {\n    childNode.rootNode = this.rootNode;\n    childNode._nodeId = ++this.rootNode.nodeCounter;\n  }\n  childNode.parentNode = this;\n  this.childNodes.push(childNode);\n  return childNode;\n};\n\n/**\n * Replaces current node with another node\n *\n * @param {Object} node Replacement node\n * @return {Object} Replacement node\n */\nMimeNode.prototype.replace = function (node) {\n  if (node === this) {\n    return this;\n  }\n  this.parentNode.childNodes.forEach(function (childNode, i) {\n    if (childNode === this) {\n      node.rootNode = this.rootNode;\n      node.parentNode = this.parentNode;\n      node._nodeId = this._nodeId;\n      this.rootNode = this;\n      this.parentNode = undefined;\n      node.parentNode.childNodes[i] = node;\n    }\n  }.bind(this));\n  return node;\n};\n\n/**\n * Removes current node from the mime tree\n *\n * @return {Object} removed node\n */\nMimeNode.prototype.remove = function () {\n  if (!this.parentNode) {\n    return this;\n  }\n  for (var i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n    if (this.parentNode.childNodes[i] === this) {\n      this.parentNode.childNodes.splice(i, 1);\n      this.parentNode = undefined;\n      this.rootNode = this;\n      return this;\n    }\n  }\n};\n\n/**\n * Sets a header value. If the value for selected key exists, it is overwritten.\n * You can set multiple values as well by using [{key:'', value:''}] or\n * {key: 'value'} as the first argument.\n *\n * @param {String|Array|Object} key Header key or a list of key value pairs\n * @param {String} value Header value\n * @return {Object} current node\n */\nMimeNode.prototype.setHeader = function (key, value) {\n  var added = false,\n    headerValue;\n\n  // Allow setting multiple headers at once\n  if (!value && key && typeof key === 'object') {\n    // allow {key:'content-type', value: 'text/plain'}\n    if (key.key && 'value' in key) {\n      this.setHeader(key.key, key.value);\n    }\n    // allow [{key:'content-type', value: 'text/plain'}]\n    else if (Array.isArray(key)) {\n      key.forEach(function (i) {\n        this.setHeader(i.key, i.value);\n      }.bind(this));\n    }\n    // allow {'content-type': 'text/plain'}\n    else {\n      Object.keys(key).forEach(function (i) {\n        this.setHeader(i, key[i]);\n      }.bind(this));\n    }\n    return this;\n  }\n  key = this._normalizeHeaderKey(key);\n  headerValue = {\n    key: key,\n    value: value\n  };\n\n  // Check if the value exists and overwrite\n  for (var i = 0, len = this._headers.length; i < len; i++) {\n    if (this._headers[i].key === key) {\n      if (!added) {\n        // replace the first match\n        this._headers[i] = headerValue;\n        added = true;\n      } else {\n        // remove following matches\n        this._headers.splice(i, 1);\n        i--;\n        len--;\n      }\n    }\n  }\n\n  // match not found, append the value\n  if (!added) {\n    this._headers.push(headerValue);\n  }\n  return this;\n};\n\n/**\n * Adds a header value. If the value for selected key exists, the value is appended\n * as a new field and old one is not touched.\n * You can set multiple values as well by using [{key:'', value:''}] or\n * {key: 'value'} as the first argument.\n *\n * @param {String|Array|Object} key Header key or a list of key value pairs\n * @param {String} value Header value\n * @return {Object} current node\n */\nMimeNode.prototype.addHeader = function (key, value) {\n  // Allow setting multiple headers at once\n  if (!value && key && typeof key === 'object') {\n    // allow {key:'content-type', value: 'text/plain'}\n    if (key.key && key.value) {\n      this.addHeader(key.key, key.value);\n    }\n    // allow [{key:'content-type', value: 'text/plain'}]\n    else if (Array.isArray(key)) {\n      key.forEach(function (i) {\n        this.addHeader(i.key, i.value);\n      }.bind(this));\n    }\n    // allow {'content-type': 'text/plain'}\n    else {\n      Object.keys(key).forEach(function (i) {\n        this.addHeader(i, key[i]);\n      }.bind(this));\n    }\n    return this;\n  } else if (Array.isArray(value)) {\n    value.forEach(function (val) {\n      this.addHeader(key, val);\n    }.bind(this));\n    return this;\n  }\n  this._headers.push({\n    key: this._normalizeHeaderKey(key),\n    value: value\n  });\n  return this;\n};\n\n/**\n * Retrieves the first mathcing value of a selected key\n *\n * @param {String} key Key to search for\n * @retun {String} Value for the key\n */\nMimeNode.prototype.getHeader = function (key) {\n  key = this._normalizeHeaderKey(key);\n  for (var i = 0, len = this._headers.length; i < len; i++) {\n    if (this._headers[i].key === key) {\n      return this._headers[i].value;\n    }\n  }\n};\n\n/**\n * Sets body content for current node. If the value is a string, charset is added automatically\n * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n * the charset yourself\n *\n * @param (String|Buffer) content Body content\n * @return {Object} current node\n */\nMimeNode.prototype.setContent = function (content) {\n  var _self = this;\n  this.content = content;\n  if (typeof this.content.pipe === 'function') {\n    // pre-stream handler. might be triggered if a stream is set as content\n    // and 'error' fires before anything is done with this stream\n    this._contentErrorHandler = function (err) {\n      _self.content.removeListener('error', _self._contentErrorHandler);\n      _self.content = err;\n    };\n    this.content.once('error', this._contentErrorHandler);\n  } else if (typeof this.content === 'string') {\n    this._isPlainText = libmime.isPlainText(this.content);\n    if (this._isPlainText && libmime.hasLongerLines(this.content, 76)) {\n      // If there are lines longer than 76 symbols/bytes do not use 7bit\n      this._hasLongLines = true;\n    }\n  }\n  return this;\n};\nMimeNode.prototype.build = function (callback) {\n  var stream = this.createReadStream();\n  var buf = [];\n  var buflen = 0;\n  var returned = false;\n  stream.on('readable', function () {\n    var chunk;\n    while ((chunk = stream.read()) !== null) {\n      buf.push(chunk);\n      buflen += chunk.length;\n    }\n  });\n  stream.once('error', function (err) {\n    if (returned) {\n      return;\n    }\n    returned = true;\n    return callback(err);\n  });\n  stream.once('end', function (chunk) {\n    if (returned) {\n      return;\n    }\n    returned = true;\n    if (chunk && chunk.length) {\n      buf.push(chunk);\n      buflen += chunk.length;\n    }\n    return callback(null, Buffer.concat(buf, buflen));\n  });\n};\nMimeNode.prototype.getTransferEncoding = function () {\n  var transferEncoding = false;\n  var contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n  if (this.content) {\n    transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n    if (!transferEncoding || ['base64', 'quoted-printable'].indexOf(transferEncoding) < 0) {\n      if (/^text\\//i.test(contentType)) {\n        // If there are no special symbols, no need to modify the text\n        if (this._isPlainText && !this._hasLongLines) {\n          transferEncoding = '7bit';\n        } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n          // detect preferred encoding for string value\n          transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n        } else {\n          // we can not check content for a stream, so either use preferred encoding or fallback to QP\n          transferEncoding = this.transferEncoding === 'B' ? 'base64' : 'quoted-printable';\n        }\n      } else if (!/^(multipart|message)\\//i.test(contentType)) {\n        transferEncoding = transferEncoding || 'base64';\n      }\n    }\n  }\n  return transferEncoding;\n};\n\n/**\n * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n *\n * @returns {String} Headers\n */\nMimeNode.prototype.buildHeaders = function () {\n  var _self = this;\n  var transferEncoding = this.getTransferEncoding();\n  var headers = [];\n  if (transferEncoding) {\n    this.setHeader('Content-Transfer-Encoding', transferEncoding);\n  }\n  if (this.filename && !this.getHeader('Content-Disposition')) {\n    this.setHeader('Content-Disposition', 'attachment');\n  }\n\n  // Ensure mandatory header fields\n  if (this.rootNode === this) {\n    if (!this.getHeader('Date')) {\n      this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n    }\n\n    // ensure that Message-Id is present\n    this.messageId();\n    if (!this.getHeader('MIME-Version')) {\n      this.setHeader('MIME-Version', '1.0');\n    }\n  }\n  this._headers.forEach(function (header) {\n    var key = header.key;\n    var value = header.value;\n    var structured;\n    var param;\n    var options = {};\n    var formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n    if (value && formattedHeaders.indexOf(key) < 0 && typeof value === 'object') {\n      Object.keys(value).forEach(function (key) {\n        if (key !== 'value') {\n          options[key] = value[key];\n        }\n      });\n      value = (value.value || '').toString();\n      if (!value.trim()) {\n        return;\n      }\n    }\n    if (options.prepared) {\n      // header value is\n      headers.push(key + ': ' + value);\n      return;\n    }\n    switch (header.key) {\n      case 'Content-Disposition':\n        structured = libmime.parseHeaderValue(value);\n        if (_self.filename) {\n          structured.params.filename = _self.filename;\n        }\n        value = libmime.buildHeaderValue(structured);\n        break;\n      case 'Content-Type':\n        structured = libmime.parseHeaderValue(value);\n        _self._handleContentType(structured);\n        if (structured.value.match(/^text\\/plain\\b/) && typeof _self.content === 'string' && /[\\u0080-\\uFFFF]/.test(_self.content)) {\n          structured.params.charset = 'utf-8';\n        }\n        value = libmime.buildHeaderValue(structured);\n        if (_self.filename) {\n          // add support for non-compliant clients like QQ webmail\n          // we can't build the value with buildHeaderValue as the value is non standard and\n          // would be converted to parameter continuation encoding that we do not want\n          param = this._encodeWords(_self.filename);\n          if (param !== _self.filename || /[\\s\"=;]/.test(param)) {\n            // include value in quotes if needed\n            param = '\"' + param + '\"';\n          }\n          value += '; name=' + param;\n        }\n        break;\n      case 'Bcc':\n        if (!_self.keepBcc) {\n          // skip BCC values\n          return;\n        }\n        break;\n    }\n    value = _self._encodeHeaderValue(key, value);\n\n    // skip empty lines\n    if (!(value || '').toString().trim()) {\n      return;\n    }\n    headers.push(libmime.foldLines(key + ': ' + value, 76));\n  }.bind(this));\n  return headers.join('\\r\\n');\n};\n\n/**\n * Streams the rfc2822 message from the current node. If this is a root node,\n * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n *\n * @return {String} Compiled message\n */\nMimeNode.prototype.createReadStream = function (options) {\n  options = options || {};\n  var outputStream = new PassThrough(options);\n  var transform;\n  this.stream(outputStream, options, function (err) {\n    if (err) {\n      outputStream.emit('error', err);\n      return;\n    }\n    outputStream.end();\n  });\n  for (var i = 0, len = this._transforms.length; i < len; i++) {\n    transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n    outputStream.once('error', function (err) {\n      transform.emit('error', err);\n    });\n    outputStream = outputStream.pipe(transform);\n  }\n  return outputStream;\n};\n\n/**\n * Appends a transform stream object to the transforms list. Final output\n * is passed through this stream before exposing\n *\n * @param {Object} transform Read-Write stream\n */\nMimeNode.prototype.transform = function (transform) {\n  this._transforms.push(transform);\n};\nMimeNode.prototype.stream = function (outputStream, options, done) {\n  var _self = this;\n  var transferEncoding = this.getTransferEncoding();\n  var contentStream;\n  var localStream;\n\n  // protect actual callback against multiple triggering\n  var returned = false;\n  var callback = function (err) {\n    if (returned) {\n      return;\n    }\n    returned = true;\n    done(err);\n  };\n\n  // pushes node content\n  function sendContent() {\n    if (_self.content) {\n      if (Object.prototype.toString.call(_self.content) === '[object Error]') {\n        // content is already errored\n        return callback(_self.content);\n      }\n      if (typeof _self.content.pipe === 'function') {\n        _self.content.removeListener('error', _self._contentErrorHandler);\n        _self._contentErrorHandler = function (err) {\n          return callback(err);\n        };\n        _self.content.once('error', _self._contentErrorHandler);\n      }\n      if (['quoted-printable', 'base64'].indexOf(transferEncoding) >= 0) {\n        contentStream = new (transferEncoding === 'base64' ? libbase64 : libqp).Encoder(options);\n        contentStream.pipe(outputStream, {\n          end: false\n        });\n        contentStream.once('end', finalize);\n        contentStream.once('error', function (err) {\n          return callback(err);\n        });\n        localStream = _self._getStream(_self.content);\n        localStream.pipe(contentStream);\n      } else {\n        // anything that is not QP or Base54 passes as-is\n        localStream = _self._getStream(_self.content);\n        localStream.pipe(outputStream, {\n          end: false\n        });\n        localStream.once('end', finalize);\n      }\n      localStream.once('error', function (err) {\n        return callback(err);\n      });\n      return;\n    } else {\n      return setImmediate(finalize);\n    }\n  }\n\n  // for multipart nodes, push child nodes\n  // for content nodes end the stream\n  function finalize() {\n    var childId = 0;\n    var processChildNode = function () {\n      if (childId >= _self.childNodes.length) {\n        outputStream.write('\\r\\n--' + _self.boundary + '--\\r\\n');\n        return callback();\n      }\n      var child = _self.childNodes[childId++];\n      outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + _self.boundary + '\\r\\n');\n      child.stream(outputStream, options, function (err) {\n        if (err) {\n          return callback(err);\n        }\n        setImmediate(processChildNode);\n      });\n    };\n    if (_self.multipart) {\n      setImmediate(processChildNode);\n    } else {\n      return callback();\n    }\n  }\n  if (this._raw) {\n    setImmediate(function () {\n      if (Object.prototype.toString.call(_self._raw) === '[object Error]') {\n        // content is already errored\n        return callback(_self._raw);\n      }\n\n      // remove default error handler (if set)\n      if (typeof _self._raw.pipe === 'function') {\n        _self._raw.removeListener('error', _self._contentErrorHandler);\n      }\n      var raw = _self._getStream(_self._raw);\n      raw.pipe(outputStream, {\n        end: false\n      });\n      raw.on('error', function (err) {\n        outputStream.emit('error', err);\n      });\n      raw.on('end', finalize);\n    });\n  } else {\n    outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n    setImmediate(sendContent);\n  }\n};\n\n/**\n * Sets envelope to be used instead of the generated one\n *\n * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n */\nMimeNode.prototype.setEnvelope = function (envelope) {\n  var list;\n  this._envelope = {\n    from: false,\n    to: []\n  };\n  if (envelope.from) {\n    list = [];\n    this._convertAddresses(this._parseAddresses(envelope.from), list);\n    list = list.filter(function (address) {\n      return address && address.address;\n    });\n    if (list.length && list[0]) {\n      this._envelope.from = list[0].address;\n    }\n  }\n  ['to', 'cc', 'bcc'].forEach(function (key) {\n    if (envelope[key]) {\n      this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);\n    }\n  }.bind(this));\n  this._envelope.to = this._envelope.to.map(function (to) {\n    return to.address;\n  }).filter(function (address) {\n    return address;\n  });\n  return this;\n};\n\n/**\n * Generates and returns an object with parsed address fields\n *\n * @return {Object} Address object\n */\nMimeNode.prototype.getAddresses = function () {\n  var addresses = {};\n  this._headers.forEach(function (header) {\n    var key = header.key.toLowerCase();\n    if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].indexOf(key) >= 0) {\n      if (!Array.isArray(addresses[key])) {\n        addresses[key] = [];\n      }\n      this._convertAddresses(this._parseAddresses(header.value), addresses[key]);\n    }\n  }.bind(this));\n  return addresses;\n};\n\n/**\n * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n *\n * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n */\nMimeNode.prototype.getEnvelope = function () {\n  if (this._envelope) {\n    return this._envelope;\n  }\n  var envelope = {\n    from: false,\n    to: []\n  };\n  this._headers.forEach(function (header) {\n    var list = [];\n    if (header.key === 'From' || !envelope.from && ['Reply-To', 'Sender'].indexOf(header.key) >= 0) {\n      this._convertAddresses(this._parseAddresses(header.value), list);\n      if (list.length && list[0]) {\n        envelope.from = list[0].address;\n      }\n    } else if (['To', 'Cc', 'Bcc'].indexOf(header.key) >= 0) {\n      this._convertAddresses(this._parseAddresses(header.value), envelope.to);\n    }\n  }.bind(this));\n  envelope.to = envelope.to.map(function (to) {\n    return to.address;\n  });\n  return envelope;\n};\n\n/**\n * Returns Message-Id value. If it does not exist, then creates one\n *\n * @return {String} Message-Id value\n */\nMimeNode.prototype.messageId = function () {\n  var messageId = this.getHeader('Message-ID');\n  // You really should define your own Message-Id field!\n  if (!messageId) {\n    messageId = this._generateMessageId();\n    this.setHeader('Message-ID', messageId);\n  }\n  return messageId;\n};\n\n/**\n * Sets pregenerated content that will be used as the output of this node\n *\n * @param {String|Buffer|Stream} Raw MIME contents\n */\nMimeNode.prototype.setRaw = function (raw) {\n  var _self = this;\n  this._raw = raw;\n  if (this._raw && typeof this._raw.pipe === 'function') {\n    // pre-stream handler. might be triggered if a stream is set as content\n    // and 'error' fires before anything is done with this stream\n    this._contentErrorHandler = function (err) {\n      _self._raw.removeListener('error', _self._contentErrorHandler);\n      _self._raw = err;\n    };\n    _self._raw.once('error', this._contentErrorHandler);\n  }\n  return this;\n};\n\n/////// PRIVATE METHODS\n\n/**\n * Detects and returns handle to a stream related with the content.\n *\n * @param {Mixed} content Node content\n * @returns {Object} Stream object\n */\nMimeNode.prototype._getStream = function (content) {\n  var contentStream;\n  if (typeof content.pipe === 'function') {\n    // assume as stream\n    return content;\n  } else if (content && typeof content.path === 'string' && !content.href) {\n    if (this.disableFileAccess) {\n      contentStream = new PassThrough();\n      setImmediate(function () {\n        contentStream.emit('error', new Error('File access rejected for ' + content.path));\n      });\n      return contentStream;\n    }\n    // read file\n    return fs.createReadStream(content.path);\n  } else if (content && typeof content.href === 'string') {\n    if (this.disableUrlAccess) {\n      contentStream = new PassThrough();\n      setImmediate(function () {\n        contentStream.emit('error', new Error('Url access rejected for ' + content.href));\n      });\n      return contentStream;\n    }\n    // fetch URL\n    return fetch(content.href);\n  } else {\n    // pass string or buffer content as a stream\n    contentStream = new PassThrough();\n    setImmediate(function () {\n      contentStream.end(content || '');\n    });\n    return contentStream;\n  }\n};\n\n/**\n * Parses addresses. Takes in a single address or an array or an\n * array of address arrays (eg. To: [[first group], [second group],...])\n *\n * @param {Mixed} addresses Addresses to be parsed\n * @return {Array} An array of address objects\n */\nMimeNode.prototype._parseAddresses = function (addresses) {\n  return [].concat.apply([], [].concat(addresses).map(function (address) {\n    if (address && address.address) {\n      address = this._convertAddresses(address);\n    }\n    return addressparser(address);\n  }.bind(this)));\n};\n\n/**\n * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n *\n * @param {String} key Key to be normalized\n * @return {String} key in Camel-Case form\n */\nMimeNode.prototype._normalizeHeaderKey = function (key) {\n  return (key || '').toString().\n  // no newlines in keys\n  replace(/\\r?\\n|\\r/g, ' ').trim().toLowerCase().\n  // use uppercase words, except MIME\n  replace(/^X\\-SMTPAPI$|^(MIME|DKIM)\\b|^[a-z]|\\-(SPF|FBL|ID|MD5)$|\\-[a-z]/ig, function (c) {\n    return c.toUpperCase();\n  }).\n  // special case\n  replace(/^Content\\-Features$/i, 'Content-features');\n};\n\n/**\n * Checks if the content type is multipart and defines boundary if needed.\n * Doesn't return anything, modifies object argument instead.\n *\n * @param {Object} structured Parsed header value for 'Content-Type' key\n */\nMimeNode.prototype._handleContentType = function (structured) {\n  this.contentType = structured.value.trim().toLowerCase();\n  this.multipart = this.contentType.split('/').reduce(function (prev, value) {\n    return prev === 'multipart' ? value : false;\n  });\n  if (this.multipart) {\n    this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n  } else {\n    this.boundary = false;\n  }\n};\n\n/**\n * Generates a multipart boundary value\n *\n * @return {String} boundary value\n */\nMimeNode.prototype._generateBoundary = function () {\n  return this.rootNode.boundaryPrefix + '-?=_' + this._nodeId + '-' + this.rootNode.baseBoundary;\n};\n\n/**\n * Encodes a header value for use in the generated rfc2822 email.\n *\n * @param {String} key Header key\n * @param {String} value Header value\n */\nMimeNode.prototype._encodeHeaderValue = function (key, value) {\n  key = this._normalizeHeaderKey(key);\n  switch (key) {\n    // Structured headers\n    case 'From':\n    case 'Sender':\n    case 'To':\n    case 'Cc':\n    case 'Bcc':\n    case 'Reply-To':\n      return this._convertAddresses(this._parseAddresses(value));\n\n    // values enclosed in <>\n    case 'Message-ID':\n    case 'In-Reply-To':\n    case 'Content-Id':\n      value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n      if (value.charAt(0) !== '<') {\n        value = '<' + value;\n      }\n      if (value.charAt(value.length - 1) !== '>') {\n        value = value + '>';\n      }\n      return value;\n\n    // space separated list of values enclosed in <>\n    case 'References':\n      value = [].concat.apply([], [].concat(value || '').map(function (elm) {\n        elm = (elm || '').toString().replace(/\\r?\\n|\\r/g, ' ').trim();\n        return elm.replace(/<[^>]*>/g, function (str) {\n          return str.replace(/\\s/g, '');\n        }).split(/\\s+/);\n      })).map(function (elm) {\n        if (elm.charAt(0) !== '<') {\n          elm = '<' + elm;\n        }\n        if (elm.charAt(elm.length - 1) !== '>') {\n          elm = elm + '>';\n        }\n        return elm;\n      });\n      return value.join(' ').trim();\n    case 'Date':\n      if (Object.prototype.toString.call(value) === '[object Date]') {\n        return value.toUTCString().replace(/GMT/, '+0000');\n      }\n      value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n      return this._encodeWords(value);\n    default:\n      value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n      // encodeWords only encodes if needed, otherwise the original string is returned\n      return this._encodeWords(value);\n  }\n};\n\n/**\n * Rebuilds address object using punycode and other adjustments\n *\n * @param {Array} addresses An array of address objects\n * @param {Array} [uniqueList] An array to be populated with addresses\n * @return {String} address string\n */\nMimeNode.prototype._convertAddresses = function (addresses, uniqueList) {\n  var values = [];\n  uniqueList = uniqueList || [];\n  [].concat(addresses || []).forEach(function (address) {\n    if (address.address) {\n      address.address = address.address.replace(/@.+$/, function (domain) {\n        // usernames are not touched and are kept as is even if these include unicode\n        // domains are punycoded by default\n        // 'jõgeva.ee' will be converted to 'xn--jgeva-dua.ee'\n        // non-unicode domains are left as is\n        return '@' + punycode.toASCII(domain.substr(1));\n      });\n      if (!address.name) {\n        values.push(address.address);\n      } else if (address.name) {\n        values.push(this._encodeAddressName(address.name) + ' <' + address.address + '>');\n      }\n      if (address.address) {\n        if (!uniqueList.filter(function (a) {\n          return a.address === address.address;\n        }).length) {\n          uniqueList.push(address);\n        }\n      }\n    } else if (address.group) {\n      values.push(this._encodeAddressName(address.name) + ':' + (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim() + ';');\n    }\n  }.bind(this));\n  return values.join(', ');\n};\n\n/**\n * If needed, mime encodes the name part\n *\n * @param {String} name Name part of an address\n * @returns {String} Mime word encoded string if needed\n */\nMimeNode.prototype._encodeAddressName = function (name) {\n  if (!/^[\\w ']*$/.test(name)) {\n    if (/^[\\x20-\\x7e]*$/.test(name)) {\n      return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n    } else {\n      return libmime.encodeWord(name, this._getTextEncoding(name), 52);\n    }\n  }\n  return name;\n};\n\n/**\n * If needed, mime encodes the name part\n *\n * @param {String} name Name part of an address\n * @returns {String} Mime word encoded string if needed\n */\nMimeNode.prototype._encodeWords = function (value) {\n  return libmime.encodeWords(value, this._getTextEncoding(value), 52);\n};\n\n/**\n * Detects best mime encoding for a text value\n *\n * @param {String} value Value to check for\n * @return {String} either 'Q' or 'B'\n */\nMimeNode.prototype._getTextEncoding = function (value) {\n  value = (value || '').toString();\n  var encoding = this.textEncoding;\n  var latinLen;\n  var nonLatinLen;\n  if (!encoding) {\n    // count latin alphabet symbols and 8-bit range symbols + control symbols\n    // if there are more latin characters, then use quoted-printable\n    // encoding, otherwise use base64\n    nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length;\n    latinLen = (value.match(/[a-z]/gi) || []).length;\n    // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n    encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n  }\n  return encoding;\n};\n\n/**\n * Generates a message id\n *\n * @return {String} Random Message-ID value\n */\nMimeNode.prototype._generateMessageId = function () {\n  return '<' + [2, 2, 2, 6].reduce(\n  // crux to generate UUID-like random strings\n  function (prev, len) {\n    return prev + '-' + crypto.randomBytes(len).toString('hex');\n  }, crypto.randomBytes(4).toString('hex')) + '@' +\n  // try to use the domain of the FROM address or fallback to server hostname\n  (this.getEnvelope().from || this.hostname || os.hostname() || 'localhost').split('@').pop() + '>';\n};","map":{"version":3,"names":["libmime","require","libqp","libbase64","punycode","addressparser","stream","PassThrough","fs","fetch","crypto","os","module","exports","MimeNode","contentType","options","nodeCounter","baseBoundary","Date","now","toString","Math","random","boundaryPrefix","disableFileAccess","disableUrlAccess","date","rootNode","keepBcc","filename","detectMimeType","split","pop","textEncoding","trim","charAt","toUpperCase","parentNode","hostname","childNodes","_nodeId","_headers","_isPlainText","_hasLongLines","_envelope","_raw","_transforms","setHeader","prototype","createChild","undefined","node","appendChild","childNode","push","replace","forEach","i","bind","remove","length","splice","key","value","added","headerValue","Array","isArray","Object","keys","_normalizeHeaderKey","len","addHeader","val","getHeader","setContent","content","_self","pipe","_contentErrorHandler","err","removeListener","once","isPlainText","hasLongerLines","build","callback","createReadStream","buf","buflen","returned","on","chunk","read","Buffer","concat","getTransferEncoding","transferEncoding","toLowerCase","indexOf","test","_getTextEncoding","buildHeaders","headers","toUTCString","messageId","header","structured","param","formattedHeaders","prepared","parseHeaderValue","params","buildHeaderValue","_handleContentType","match","charset","_encodeWords","_encodeHeaderValue","foldLines","join","outputStream","transform","emit","end","done","contentStream","localStream","sendContent","call","Encoder","finalize","_getStream","setImmediate","childId","processChildNode","write","boundary","child","multipart","raw","setEnvelope","envelope","list","from","to","_convertAddresses","_parseAddresses","filter","address","map","getAddresses","addresses","getEnvelope","_generateMessageId","setRaw","path","href","Error","apply","c","reduce","prev","_generateBoundary","elm","str","uniqueList","values","domain","toASCII","substr","name","_encodeAddressName","a","group","encodeWord","encodeWords","encoding","latinLen","nonLatinLen","randomBytes"],"sources":["C:/Users/Admin/OneDrive/Desktop/Online Book Thrift Store/frontend/node_modules/buildmail/lib/buildmail.js"],"sourcesContent":["'use strict';\n\nvar libmime = require('libmime');\nvar libqp = require('libqp');\nvar libbase64 = require('libbase64');\nvar punycode = require('punycode');\nvar addressparser = require('addressparser');\nvar stream = require('stream');\nvar PassThrough = stream.PassThrough;\nvar fs = require('fs');\nvar fetch = require('nodemailer-fetch');\nvar crypto = require('crypto');\nvar os = require('os');\n\nmodule.exports = MimeNode;\n\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\nfunction MimeNode(contentType, options) {\n    this.nodeCounter = 0;\n\n    options = options || {};\n\n    /**\n     * shared part of the unique multipart boundary\n     */\n    this.baseBoundary = options.baseBoundary || Date.now().toString() + Math.random();\n    this.boundaryPrefix = options.boundaryPrefix || '----sinikael';\n\n    this.disableFileAccess = !!options.disableFileAccess;\n    this.disableUrlAccess = !!options.disableUrlAccess;\n\n    /**\n     * If date headers is missing and current node is the root, this value is used instead\n     */\n    this.date = new Date();\n\n    /**\n     * Root node for current mime tree\n     */\n    this.rootNode = options.rootNode || this;\n\n    /**\n     * If true include Bcc in generated headers (if available)\n     */\n    this.keepBcc = !!options.keepBcc;\n\n    /**\n     * If filename is specified but contentType is not (probably an attachment)\n     * detect the content type from filename extension\n     */\n    if (options.filename) {\n        /**\n         * Filename for this node. Useful with attachments\n         */\n        this.filename = options.filename;\n        if (!contentType) {\n            contentType = libmime.detectMimeType(this.filename.split('.').pop());\n        }\n    }\n\n    /**\n     * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n     */\n    this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n\n    /**\n     * Immediate parent for this node (or undefined if not set)\n     */\n    this.parentNode = options.parentNode;\n\n    /**\n     * Hostname for default message-id values\n     */\n    this.hostname = options.hostname;\n\n    /**\n     * An array for possible child nodes\n     */\n    this.childNodes = [];\n\n    /**\n     * Used for generating unique boundaries (prepended to the shared base)\n     */\n    this._nodeId = ++this.rootNode.nodeCounter;\n\n    /**\n     * A list of header values for this node in the form of [{key:'', value:''}]\n     */\n    this._headers = [];\n\n    /**\n     * True if the content only uses ASCII printable characters\n     * @type {Boolean}\n     */\n    this._isPlainText = false;\n\n    /**\n     * True if the content is plain text but has longer lines than allowed\n     * @type {Boolean}\n     */\n    this._hasLongLines = false;\n\n    /**\n     * If set, use instead this value for envelopes instead of generating one\n     * @type {Boolean}\n     */\n    this._envelope = false;\n\n    /**\n     * If set then use this value as the stream content instead of building it\n     * @type {String|Buffer|Stream}\n     */\n    this._raw = false;\n\n    /**\n     * Additional transform streams that the message will be piped before\n     * exposing by createReadStream\n     * @type {Array}\n     */\n    this._transforms = [];\n\n    /**\n     * If content type is set (or derived from the filename) add it to headers\n     */\n    if (contentType) {\n        this.setHeader('Content-Type', contentType);\n    }\n}\n\n/////// PUBLIC METHODS\n\n/**\n * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n *\n * @param {String} [contentType] Optional content type\n * @param {Object} [options] Optional options object\n * @return {Object} Created node object\n */\nMimeNode.prototype.createChild = function (contentType, options) {\n    if (!options && typeof contentType === 'object') {\n        options = contentType;\n        contentType = undefined;\n    }\n    var node = new MimeNode(contentType, options);\n    this.appendChild(node);\n    return node;\n};\n\n/**\n * Appends an existing node to the mime tree. Removes the node from an existing\n * tree if needed\n *\n * @param {Object} childNode node to be appended\n * @return {Object} Appended node object\n */\nMimeNode.prototype.appendChild = function (childNode) {\n\n    if (childNode.rootNode !== this.rootNode) {\n        childNode.rootNode = this.rootNode;\n        childNode._nodeId = ++this.rootNode.nodeCounter;\n    }\n\n    childNode.parentNode = this;\n\n    this.childNodes.push(childNode);\n    return childNode;\n};\n\n/**\n * Replaces current node with another node\n *\n * @param {Object} node Replacement node\n * @return {Object} Replacement node\n */\nMimeNode.prototype.replace = function (node) {\n    if (node === this) {\n        return this;\n    }\n\n    this.parentNode.childNodes.forEach(function (childNode, i) {\n        if (childNode === this) {\n\n            node.rootNode = this.rootNode;\n            node.parentNode = this.parentNode;\n            node._nodeId = this._nodeId;\n\n            this.rootNode = this;\n            this.parentNode = undefined;\n\n            node.parentNode.childNodes[i] = node;\n        }\n    }.bind(this));\n\n    return node;\n};\n\n/**\n * Removes current node from the mime tree\n *\n * @return {Object} removed node\n */\nMimeNode.prototype.remove = function () {\n    if (!this.parentNode) {\n        return this;\n    }\n\n    for (var i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n        if (this.parentNode.childNodes[i] === this) {\n            this.parentNode.childNodes.splice(i, 1);\n            this.parentNode = undefined;\n            this.rootNode = this;\n            return this;\n        }\n    }\n};\n\n/**\n * Sets a header value. If the value for selected key exists, it is overwritten.\n * You can set multiple values as well by using [{key:'', value:''}] or\n * {key: 'value'} as the first argument.\n *\n * @param {String|Array|Object} key Header key or a list of key value pairs\n * @param {String} value Header value\n * @return {Object} current node\n */\nMimeNode.prototype.setHeader = function (key, value) {\n    var added = false,\n        headerValue;\n\n    // Allow setting multiple headers at once\n    if (!value && key && typeof key === 'object') {\n        // allow {key:'content-type', value: 'text/plain'}\n        if (key.key && 'value' in key) {\n            this.setHeader(key.key, key.value);\n        }\n        // allow [{key:'content-type', value: 'text/plain'}]\n        else if (Array.isArray(key)) {\n            key.forEach(function (i) {\n                this.setHeader(i.key, i.value);\n            }.bind(this));\n        }\n        // allow {'content-type': 'text/plain'}\n        else {\n            Object.keys(key).forEach(function (i) {\n                this.setHeader(i, key[i]);\n            }.bind(this));\n        }\n        return this;\n    }\n\n    key = this._normalizeHeaderKey(key);\n\n    headerValue = {\n        key: key,\n        value: value\n    };\n\n    // Check if the value exists and overwrite\n    for (var i = 0, len = this._headers.length; i < len; i++) {\n        if (this._headers[i].key === key) {\n            if (!added) {\n                // replace the first match\n                this._headers[i] = headerValue;\n                added = true;\n            } else {\n                // remove following matches\n                this._headers.splice(i, 1);\n                i--;\n                len--;\n            }\n        }\n    }\n\n    // match not found, append the value\n    if (!added) {\n        this._headers.push(headerValue);\n    }\n\n    return this;\n};\n\n/**\n * Adds a header value. If the value for selected key exists, the value is appended\n * as a new field and old one is not touched.\n * You can set multiple values as well by using [{key:'', value:''}] or\n * {key: 'value'} as the first argument.\n *\n * @param {String|Array|Object} key Header key or a list of key value pairs\n * @param {String} value Header value\n * @return {Object} current node\n */\nMimeNode.prototype.addHeader = function (key, value) {\n\n    // Allow setting multiple headers at once\n    if (!value && key && typeof key === 'object') {\n        // allow {key:'content-type', value: 'text/plain'}\n        if (key.key && key.value) {\n            this.addHeader(key.key, key.value);\n        }\n        // allow [{key:'content-type', value: 'text/plain'}]\n        else if (Array.isArray(key)) {\n            key.forEach(function (i) {\n                this.addHeader(i.key, i.value);\n            }.bind(this));\n        }\n        // allow {'content-type': 'text/plain'}\n        else {\n            Object.keys(key).forEach(function (i) {\n                this.addHeader(i, key[i]);\n            }.bind(this));\n        }\n        return this;\n    } else if (Array.isArray(value)) {\n        value.forEach(function (val) {\n            this.addHeader(key, val);\n        }.bind(this));\n        return this;\n    }\n\n    this._headers.push({\n        key: this._normalizeHeaderKey(key),\n        value: value\n    });\n\n    return this;\n};\n\n/**\n * Retrieves the first mathcing value of a selected key\n *\n * @param {String} key Key to search for\n * @retun {String} Value for the key\n */\nMimeNode.prototype.getHeader = function (key) {\n    key = this._normalizeHeaderKey(key);\n    for (var i = 0, len = this._headers.length; i < len; i++) {\n        if (this._headers[i].key === key) {\n            return this._headers[i].value;\n        }\n    }\n};\n\n/**\n * Sets body content for current node. If the value is a string, charset is added automatically\n * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n * the charset yourself\n *\n * @param (String|Buffer) content Body content\n * @return {Object} current node\n */\nMimeNode.prototype.setContent = function (content) {\n    var _self = this;\n    this.content = content;\n    if (typeof this.content.pipe === 'function') {\n        // pre-stream handler. might be triggered if a stream is set as content\n        // and 'error' fires before anything is done with this stream\n        this._contentErrorHandler = function (err) {\n            _self.content.removeListener('error', _self._contentErrorHandler);\n            _self.content = err;\n        };\n        this.content.once('error', this._contentErrorHandler);\n    } else if (typeof this.content === 'string') {\n        this._isPlainText = libmime.isPlainText(this.content);\n        if (this._isPlainText && libmime.hasLongerLines(this.content, 76)) {\n            // If there are lines longer than 76 symbols/bytes do not use 7bit\n            this._hasLongLines = true;\n        }\n    }\n    return this;\n};\n\nMimeNode.prototype.build = function (callback) {\n    var stream = this.createReadStream();\n    var buf = [];\n    var buflen = 0;\n    var returned = false;\n\n    stream.on('readable', function () {\n        var chunk;\n\n        while ((chunk = stream.read()) !== null) {\n            buf.push(chunk);\n            buflen += chunk.length;\n        }\n    });\n\n    stream.once('error', function (err) {\n        if (returned) {\n            return;\n        }\n        returned = true;\n\n        return callback(err);\n    });\n\n    stream.once('end', function (chunk) {\n        if (returned) {\n            return;\n        }\n        returned = true;\n\n        if (chunk && chunk.length) {\n            buf.push(chunk);\n            buflen += chunk.length;\n        }\n        return callback(null, Buffer.concat(buf, buflen));\n    });\n};\n\nMimeNode.prototype.getTransferEncoding = function () {\n    var transferEncoding = false;\n    var contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n\n    if (this.content) {\n        transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n        if (!transferEncoding || ['base64', 'quoted-printable'].indexOf(transferEncoding) < 0) {\n            if (/^text\\//i.test(contentType)) {\n                // If there are no special symbols, no need to modify the text\n                if (this._isPlainText && !this._hasLongLines) {\n                    transferEncoding = '7bit';\n                } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n                    // detect preferred encoding for string value\n                    transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n                } else {\n                    // we can not check content for a stream, so either use preferred encoding or fallback to QP\n                    transferEncoding = this.transferEncoding === 'B' ? 'base64' : 'quoted-printable';\n                }\n            } else if (!/^(multipart|message)\\//i.test(contentType)) {\n                transferEncoding = transferEncoding || 'base64';\n            }\n        }\n    }\n    return transferEncoding;\n};\n\n/**\n * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n *\n * @returns {String} Headers\n */\nMimeNode.prototype.buildHeaders = function () {\n    var _self = this;\n    var transferEncoding = this.getTransferEncoding();\n    var headers = [];\n\n    if (transferEncoding) {\n        this.setHeader('Content-Transfer-Encoding', transferEncoding);\n    }\n\n    if (this.filename && !this.getHeader('Content-Disposition')) {\n        this.setHeader('Content-Disposition', 'attachment');\n    }\n\n    // Ensure mandatory header fields\n    if (this.rootNode === this) {\n        if (!this.getHeader('Date')) {\n            this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n        }\n\n        // ensure that Message-Id is present\n        this.messageId();\n\n        if (!this.getHeader('MIME-Version')) {\n            this.setHeader('MIME-Version', '1.0');\n        }\n    }\n\n    this._headers.forEach(function (header) {\n        var key = header.key;\n        var value = header.value;\n        var structured;\n        var param;\n        var options = {};\n        var formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n\n        if (value && formattedHeaders.indexOf(key) < 0 && typeof value === 'object') {\n            Object.keys(value).forEach(function (key) {\n                if (key !== 'value') {\n                    options[key] = value[key];\n                }\n            });\n            value = (value.value || '').toString();\n            if (!value.trim()) {\n                return;\n            }\n        }\n\n        if (options.prepared) {\n            // header value is\n            headers.push(key + ': ' + value);\n            return;\n        }\n\n        switch (header.key) {\n            case 'Content-Disposition':\n                structured = libmime.parseHeaderValue(value);\n                if (_self.filename) {\n                    structured.params.filename = _self.filename;\n                }\n                value = libmime.buildHeaderValue(structured);\n                break;\n            case 'Content-Type':\n                structured = libmime.parseHeaderValue(value);\n\n                _self._handleContentType(structured);\n\n                if (structured.value.match(/^text\\/plain\\b/) && typeof _self.content === 'string' && /[\\u0080-\\uFFFF]/.test(_self.content)) {\n                    structured.params.charset = 'utf-8';\n                }\n\n                value = libmime.buildHeaderValue(structured);\n\n                if (_self.filename) {\n                    // add support for non-compliant clients like QQ webmail\n                    // we can't build the value with buildHeaderValue as the value is non standard and\n                    // would be converted to parameter continuation encoding that we do not want\n                    param = this._encodeWords(_self.filename);\n                    if (param !== _self.filename || /[\\s\"=;]/.test(param)) {\n                        // include value in quotes if needed\n                        param = '\"' + param + '\"';\n                    }\n                    value += '; name=' + param;\n                }\n                break;\n            case 'Bcc':\n                if (!_self.keepBcc) {\n                    // skip BCC values\n                    return;\n                }\n                break;\n        }\n\n        value = _self._encodeHeaderValue(key, value);\n\n        // skip empty lines\n        if (!(value || '').toString().trim()) {\n            return;\n        }\n\n        headers.push(libmime.foldLines(key + ': ' + value, 76));\n    }.bind(this));\n\n    return headers.join('\\r\\n');\n};\n\n/**\n * Streams the rfc2822 message from the current node. If this is a root node,\n * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n *\n * @return {String} Compiled message\n */\nMimeNode.prototype.createReadStream = function (options) {\n    options = options || {};\n\n    var outputStream = new PassThrough(options);\n    var transform;\n\n    this.stream(outputStream, options, function (err) {\n        if (err) {\n            outputStream.emit('error', err);\n            return;\n        }\n        outputStream.end();\n    });\n\n    for (var i = 0, len = this._transforms.length; i < len; i++) {\n        transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n        outputStream.once('error', function (err) {\n            transform.emit('error', err);\n        });\n        outputStream = outputStream.pipe(transform);\n    }\n\n    return outputStream;\n};\n\n/**\n * Appends a transform stream object to the transforms list. Final output\n * is passed through this stream before exposing\n *\n * @param {Object} transform Read-Write stream\n */\nMimeNode.prototype.transform = function (transform) {\n    this._transforms.push(transform);\n};\n\nMimeNode.prototype.stream = function (outputStream, options, done) {\n    var _self = this;\n    var transferEncoding = this.getTransferEncoding();\n    var contentStream;\n    var localStream;\n\n    // protect actual callback against multiple triggering\n    var returned = false;\n    var callback = function (err) {\n        if (returned) {\n            return;\n        }\n        returned = true;\n        done(err);\n    };\n\n    // pushes node content\n    function sendContent() {\n        if (_self.content) {\n\n            if (Object.prototype.toString.call(_self.content) === '[object Error]') {\n                // content is already errored\n                return callback(_self.content);\n            }\n\n            if (typeof _self.content.pipe === 'function') {\n                _self.content.removeListener('error', _self._contentErrorHandler);\n                _self._contentErrorHandler = function (err) {\n                    return callback(err);\n                };\n                _self.content.once('error', _self._contentErrorHandler);\n            }\n\n            if (['quoted-printable', 'base64'].indexOf(transferEncoding) >= 0) {\n                contentStream = new(transferEncoding === 'base64' ? libbase64 : libqp).Encoder(options);\n\n                contentStream.pipe(outputStream, {\n                    end: false\n                });\n                contentStream.once('end', finalize);\n                contentStream.once('error', function (err) {\n                    return callback(err);\n                });\n\n                localStream = _self._getStream(_self.content);\n                localStream.pipe(contentStream);\n            } else {\n                // anything that is not QP or Base54 passes as-is\n                localStream = _self._getStream(_self.content);\n                localStream.pipe(outputStream, {\n                    end: false\n                });\n                localStream.once('end', finalize);\n            }\n\n            localStream.once('error', function (err) {\n                return callback(err);\n            });\n\n            return;\n        } else {\n            return setImmediate(finalize);\n        }\n    }\n\n    // for multipart nodes, push child nodes\n    // for content nodes end the stream\n    function finalize() {\n        var childId = 0;\n        var processChildNode = function () {\n            if (childId >= _self.childNodes.length) {\n                outputStream.write('\\r\\n--' + _self.boundary + '--\\r\\n');\n                return callback();\n            }\n            var child = _self.childNodes[childId++];\n            outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + _self.boundary + '\\r\\n');\n            child.stream(outputStream, options, function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                setImmediate(processChildNode);\n            });\n        };\n\n        if (_self.multipart) {\n            setImmediate(processChildNode);\n        } else {\n            return callback();\n        }\n    }\n\n    if (this._raw) {\n        setImmediate(function () {\n            if (Object.prototype.toString.call(_self._raw) === '[object Error]') {\n                // content is already errored\n                return callback(_self._raw);\n            }\n\n            // remove default error handler (if set)\n            if (typeof _self._raw.pipe === 'function') {\n                _self._raw.removeListener('error', _self._contentErrorHandler);\n            }\n\n            var raw = _self._getStream(_self._raw);\n            raw.pipe(outputStream, {\n                end: false\n            });\n            raw.on('error', function (err) {\n                outputStream.emit('error', err);\n            });\n            raw.on('end', finalize);\n        });\n    } else {\n        outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n        setImmediate(sendContent);\n    }\n};\n\n/**\n * Sets envelope to be used instead of the generated one\n *\n * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n */\nMimeNode.prototype.setEnvelope = function (envelope) {\n    var list;\n\n    this._envelope = {\n        from: false,\n        to: []\n    };\n\n    if (envelope.from) {\n        list = [];\n        this._convertAddresses(this._parseAddresses(envelope.from), list);\n        list = list.filter(function (address) {\n            return address && address.address;\n        });\n        if (list.length && list[0]) {\n            this._envelope.from = list[0].address;\n        }\n    }\n    ['to', 'cc', 'bcc'].forEach(function (key) {\n        if (envelope[key]) {\n            this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);\n        }\n    }.bind(this));\n\n    this._envelope.to = this._envelope.to.map(function (to) {\n        return to.address;\n    }).filter(function (address) {\n        return address;\n    });\n\n    return this;\n};\n\n/**\n * Generates and returns an object with parsed address fields\n *\n * @return {Object} Address object\n */\nMimeNode.prototype.getAddresses = function () {\n    var addresses = {};\n\n    this._headers.forEach(function (header) {\n        var key = header.key.toLowerCase();\n        if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].indexOf(key) >= 0) {\n            if (!Array.isArray(addresses[key])) {\n                addresses[key] = [];\n            }\n\n            this._convertAddresses(this._parseAddresses(header.value), addresses[key]);\n        }\n    }.bind(this));\n\n    return addresses;\n};\n\n/**\n * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n *\n * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n */\nMimeNode.prototype.getEnvelope = function () {\n    if (this._envelope) {\n        return this._envelope;\n    }\n\n    var envelope = {\n        from: false,\n        to: []\n    };\n    this._headers.forEach(function (header) {\n        var list = [];\n        if (header.key === 'From' || (!envelope.from && ['Reply-To', 'Sender'].indexOf(header.key) >= 0)) {\n            this._convertAddresses(this._parseAddresses(header.value), list);\n            if (list.length && list[0]) {\n                envelope.from = list[0].address;\n            }\n        } else if (['To', 'Cc', 'Bcc'].indexOf(header.key) >= 0) {\n            this._convertAddresses(this._parseAddresses(header.value), envelope.to);\n        }\n    }.bind(this));\n\n    envelope.to = envelope.to.map(function (to) {\n        return to.address;\n    });\n\n    return envelope;\n};\n\n/**\n * Returns Message-Id value. If it does not exist, then creates one\n *\n * @return {String} Message-Id value\n */\nMimeNode.prototype.messageId = function () {\n    var messageId = this.getHeader('Message-ID');\n    // You really should define your own Message-Id field!\n    if (!messageId) {\n        messageId = this._generateMessageId();\n        this.setHeader('Message-ID', messageId);\n    }\n    return messageId;\n};\n\n/**\n * Sets pregenerated content that will be used as the output of this node\n *\n * @param {String|Buffer|Stream} Raw MIME contents\n */\nMimeNode.prototype.setRaw = function (raw) {\n    var _self = this;\n\n    this._raw = raw;\n\n    if (this._raw && typeof this._raw.pipe === 'function') {\n        // pre-stream handler. might be triggered if a stream is set as content\n        // and 'error' fires before anything is done with this stream\n        this._contentErrorHandler = function (err) {\n            _self._raw.removeListener('error', _self._contentErrorHandler);\n            _self._raw = err;\n        };\n        _self._raw.once('error', this._contentErrorHandler);\n    }\n\n    return this;\n};\n\n/////// PRIVATE METHODS\n\n/**\n * Detects and returns handle to a stream related with the content.\n *\n * @param {Mixed} content Node content\n * @returns {Object} Stream object\n */\nMimeNode.prototype._getStream = function (content) {\n    var contentStream;\n\n    if (typeof content.pipe === 'function') {\n        // assume as stream\n        return content;\n    } else if (content && typeof content.path === 'string' && !content.href) {\n        if (this.disableFileAccess) {\n            contentStream = new PassThrough();\n            setImmediate(function () {\n                contentStream.emit('error', new Error('File access rejected for ' + content.path));\n            });\n            return contentStream;\n        }\n        // read file\n        return fs.createReadStream(content.path);\n    } else if (content && typeof content.href === 'string') {\n        if (this.disableUrlAccess) {\n            contentStream = new PassThrough();\n            setImmediate(function () {\n                contentStream.emit('error', new Error('Url access rejected for ' + content.href));\n            });\n            return contentStream;\n        }\n        // fetch URL\n        return fetch(content.href);\n    } else {\n        // pass string or buffer content as a stream\n        contentStream = new PassThrough();\n        setImmediate(function () {\n            contentStream.end(content || '');\n        });\n        return contentStream;\n    }\n};\n\n/**\n * Parses addresses. Takes in a single address or an array or an\n * array of address arrays (eg. To: [[first group], [second group],...])\n *\n * @param {Mixed} addresses Addresses to be parsed\n * @return {Array} An array of address objects\n */\nMimeNode.prototype._parseAddresses = function (addresses) {\n    return [].concat.apply([], [].concat(addresses).map(function (address) {\n        if (address && address.address) {\n            address = this._convertAddresses(address);\n        }\n        return addressparser(address);\n    }.bind(this)));\n};\n\n/**\n * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n *\n * @param {String} key Key to be normalized\n * @return {String} key in Camel-Case form\n */\nMimeNode.prototype._normalizeHeaderKey = function (key) {\n    return (key || '').toString().\n        // no newlines in keys\n    replace(/\\r?\\n|\\r/g, ' ').\n    trim().toLowerCase().\n        // use uppercase words, except MIME\n    replace(/^X\\-SMTPAPI$|^(MIME|DKIM)\\b|^[a-z]|\\-(SPF|FBL|ID|MD5)$|\\-[a-z]/ig,\n            function (c) {\n                return c.toUpperCase();\n            }).\n        // special case\n    replace(/^Content\\-Features$/i, 'Content-features');\n};\n\n/**\n * Checks if the content type is multipart and defines boundary if needed.\n * Doesn't return anything, modifies object argument instead.\n *\n * @param {Object} structured Parsed header value for 'Content-Type' key\n */\nMimeNode.prototype._handleContentType = function (structured) {\n    this.contentType = structured.value.trim().toLowerCase();\n\n    this.multipart = this.contentType.split('/').reduce(function (prev, value) {\n        return prev === 'multipart' ? value : false;\n    });\n\n    if (this.multipart) {\n        this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n    } else {\n        this.boundary = false;\n    }\n};\n\n/**\n * Generates a multipart boundary value\n *\n * @return {String} boundary value\n */\nMimeNode.prototype._generateBoundary = function () {\n    return this.rootNode.boundaryPrefix + '-?=_' + this._nodeId + '-' + this.rootNode.baseBoundary;\n};\n\n/**\n * Encodes a header value for use in the generated rfc2822 email.\n *\n * @param {String} key Header key\n * @param {String} value Header value\n */\nMimeNode.prototype._encodeHeaderValue = function (key, value) {\n    key = this._normalizeHeaderKey(key);\n\n    switch (key) {\n\n        // Structured headers\n        case 'From':\n        case 'Sender':\n        case 'To':\n        case 'Cc':\n        case 'Bcc':\n        case 'Reply-To':\n            return this._convertAddresses(this._parseAddresses(value));\n\n            // values enclosed in <>\n        case 'Message-ID':\n        case 'In-Reply-To':\n        case 'Content-Id':\n            value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n            if (value.charAt(0) !== '<') {\n                value = '<' + value;\n            }\n\n            if (value.charAt(value.length - 1) !== '>') {\n                value = value + '>';\n            }\n            return value;\n\n            // space separated list of values enclosed in <>\n        case 'References':\n            value = [].concat.apply([], [].concat(value || '').map(function (elm) {\n                elm = (elm || '').toString().replace(/\\r?\\n|\\r/g, ' ').trim();\n                return elm.replace(/<[^>]*>/g, function (str) {\n                    return str.replace(/\\s/g, '');\n                }).split(/\\s+/);\n            })).map(function (elm) {\n                if (elm.charAt(0) !== '<') {\n                    elm = '<' + elm;\n                }\n                if (elm.charAt(elm.length - 1) !== '>') {\n                    elm = elm + '>';\n                }\n                return elm;\n            });\n\n            return value.join(' ').trim();\n\n        case 'Date':\n            if (Object.prototype.toString.call(value) === '[object Date]') {\n                return value.toUTCString().replace(/GMT/, '+0000');\n            }\n\n            value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n            return this._encodeWords(value);\n\n        default:\n            value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n            // encodeWords only encodes if needed, otherwise the original string is returned\n            return this._encodeWords(value);\n    }\n};\n\n/**\n * Rebuilds address object using punycode and other adjustments\n *\n * @param {Array} addresses An array of address objects\n * @param {Array} [uniqueList] An array to be populated with addresses\n * @return {String} address string\n */\nMimeNode.prototype._convertAddresses = function (addresses, uniqueList) {\n    var values = [];\n\n    uniqueList = uniqueList || [];\n\n    [].concat(addresses || []).forEach(function (address) {\n        if (address.address) {\n            address.address = address.address.replace(/@.+$/, function (domain) {\n                // usernames are not touched and are kept as is even if these include unicode\n                // domains are punycoded by default\n                // 'jõgeva.ee' will be converted to 'xn--jgeva-dua.ee'\n                // non-unicode domains are left as is\n                return '@' + punycode.toASCII(domain.substr(1));\n            });\n\n            if (!address.name) {\n                values.push(address.address);\n            } else if (address.name) {\n                values.push(this._encodeAddressName(address.name) + ' <' + address.address + '>');\n            }\n\n            if (address.address) {\n                if (!uniqueList.filter(\n                        function (a) {\n                            return a.address === address.address;\n                        }).length) {\n                    uniqueList.push(address);\n                }\n            }\n        } else if (address.group) {\n            values.push(this._encodeAddressName(address.name) + ':' + (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim() + ';');\n        }\n    }.bind(this));\n\n    return values.join(', ');\n};\n\n/**\n * If needed, mime encodes the name part\n *\n * @param {String} name Name part of an address\n * @returns {String} Mime word encoded string if needed\n */\nMimeNode.prototype._encodeAddressName = function (name) {\n    if (!/^[\\w ']*$/.test(name)) {\n        if (/^[\\x20-\\x7e]*$/.test(name)) {\n            return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n        } else {\n            return libmime.encodeWord(name, this._getTextEncoding(name), 52);\n        }\n    }\n    return name;\n};\n\n/**\n * If needed, mime encodes the name part\n *\n * @param {String} name Name part of an address\n * @returns {String} Mime word encoded string if needed\n */\nMimeNode.prototype._encodeWords = function (value) {\n    return libmime.encodeWords(value, this._getTextEncoding(value), 52);\n};\n\n/**\n * Detects best mime encoding for a text value\n *\n * @param {String} value Value to check for\n * @return {String} either 'Q' or 'B'\n */\nMimeNode.prototype._getTextEncoding = function (value) {\n    value = (value || '').toString();\n\n    var encoding = this.textEncoding;\n    var latinLen;\n    var nonLatinLen;\n\n    if (!encoding) {\n        // count latin alphabet symbols and 8-bit range symbols + control symbols\n        // if there are more latin characters, then use quoted-printable\n        // encoding, otherwise use base64\n        nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length;\n        latinLen = (value.match(/[a-z]/gi) || []).length;\n        // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n        encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n    }\n    return encoding;\n};\n\n/**\n * Generates a message id\n *\n * @return {String} Random Message-ID value\n */\nMimeNode.prototype._generateMessageId = function () {\n    return '<' + [2, 2, 2, 6].reduce(\n            // crux to generate UUID-like random strings\n            function (prev, len) {\n                return prev + '-' + crypto.randomBytes(len).toString('hex');\n            }, crypto.randomBytes(4).toString('hex')) +\n        '@' +\n        // try to use the domain of the FROM address or fallback to server hostname\n        (this.getEnvelope().from || this.hostname || os.hostname() || 'localhost').split('@').pop() + '>';\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,OAAO,GAAGC,OAAO,CAAC,SAAS,CAAC;AAChC,IAAIC,KAAK,GAAGD,OAAO,CAAC,OAAO,CAAC;AAC5B,IAAIE,SAAS,GAAGF,OAAO,CAAC,WAAW,CAAC;AACpC,IAAIG,QAAQ,GAAGH,OAAO,CAAC,UAAU,CAAC;AAClC,IAAII,aAAa,GAAGJ,OAAO,CAAC,eAAe,CAAC;AAC5C,IAAIK,MAAM,GAAGL,OAAO,CAAC,QAAQ,CAAC;AAC9B,IAAIM,WAAW,GAAGD,MAAM,CAACC,WAAW;AACpC,IAAIC,EAAE,GAAGP,OAAO,CAAC,IAAI,CAAC;AACtB,IAAIQ,KAAK,GAAGR,OAAO,CAAC,kBAAkB,CAAC;AACvC,IAAIS,MAAM,GAAGT,OAAO,CAAC,QAAQ,CAAC;AAC9B,IAAIU,EAAE,GAAGV,OAAO,CAAC,IAAI,CAAC;AAEtBW,MAAM,CAACC,OAAO,GAAGC,QAAQ;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,QAAQA,CAACC,WAAW,EAAEC,OAAO,EAAE;EACpC,IAAI,CAACC,WAAW,GAAG,CAAC;EAEpBD,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;;EAEvB;AACJ;AACA;EACI,IAAI,CAACE,YAAY,GAAGF,OAAO,CAACE,YAAY,IAAIC,IAAI,CAACC,GAAG,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,GAAGC,IAAI,CAACC,MAAM,CAAC,CAAC;EACjF,IAAI,CAACC,cAAc,GAAGR,OAAO,CAACQ,cAAc,IAAI,cAAc;EAE9D,IAAI,CAACC,iBAAiB,GAAG,CAAC,CAACT,OAAO,CAACS,iBAAiB;EACpD,IAAI,CAACC,gBAAgB,GAAG,CAAC,CAACV,OAAO,CAACU,gBAAgB;;EAElD;AACJ;AACA;EACI,IAAI,CAACC,IAAI,GAAG,IAAIR,IAAI,CAAC,CAAC;;EAEtB;AACJ;AACA;EACI,IAAI,CAACS,QAAQ,GAAGZ,OAAO,CAACY,QAAQ,IAAI,IAAI;;EAExC;AACJ;AACA;EACI,IAAI,CAACC,OAAO,GAAG,CAAC,CAACb,OAAO,CAACa,OAAO;;EAEhC;AACJ;AACA;AACA;EACI,IAAIb,OAAO,CAACc,QAAQ,EAAE;IAClB;AACR;AACA;IACQ,IAAI,CAACA,QAAQ,GAAGd,OAAO,CAACc,QAAQ;IAChC,IAAI,CAACf,WAAW,EAAE;MACdA,WAAW,GAAGf,OAAO,CAAC+B,cAAc,CAAC,IAAI,CAACD,QAAQ,CAACE,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAC,CAAC,CAAC;IACxE;EACJ;;EAEA;AACJ;AACA;EACI,IAAI,CAACC,YAAY,GAAG,CAAClB,OAAO,CAACkB,YAAY,IAAI,EAAE,EAAEb,QAAQ,CAAC,CAAC,CAACc,IAAI,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;;EAE1F;AACJ;AACA;EACI,IAAI,CAACC,UAAU,GAAGtB,OAAO,CAACsB,UAAU;;EAEpC;AACJ;AACA;EACI,IAAI,CAACC,QAAQ,GAAGvB,OAAO,CAACuB,QAAQ;;EAEhC;AACJ;AACA;EACI,IAAI,CAACC,UAAU,GAAG,EAAE;;EAEpB;AACJ;AACA;EACI,IAAI,CAACC,OAAO,GAAG,EAAE,IAAI,CAACb,QAAQ,CAACX,WAAW;;EAE1C;AACJ;AACA;EACI,IAAI,CAACyB,QAAQ,GAAG,EAAE;;EAElB;AACJ;AACA;AACA;EACI,IAAI,CAACC,YAAY,GAAG,KAAK;;EAEzB;AACJ;AACA;AACA;EACI,IAAI,CAACC,aAAa,GAAG,KAAK;;EAE1B;AACJ;AACA;AACA;EACI,IAAI,CAACC,SAAS,GAAG,KAAK;;EAEtB;AACJ;AACA;AACA;EACI,IAAI,CAACC,IAAI,GAAG,KAAK;;EAEjB;AACJ;AACA;AACA;AACA;EACI,IAAI,CAACC,WAAW,GAAG,EAAE;;EAErB;AACJ;AACA;EACI,IAAIhC,WAAW,EAAE;IACb,IAAI,CAACiC,SAAS,CAAC,cAAc,EAAEjC,WAAW,CAAC;EAC/C;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACAD,QAAQ,CAACmC,SAAS,CAACC,WAAW,GAAG,UAAUnC,WAAW,EAAEC,OAAO,EAAE;EAC7D,IAAI,CAACA,OAAO,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE;IAC7CC,OAAO,GAAGD,WAAW;IACrBA,WAAW,GAAGoC,SAAS;EAC3B;EACA,IAAIC,IAAI,GAAG,IAAItC,QAAQ,CAACC,WAAW,EAAEC,OAAO,CAAC;EAC7C,IAAI,CAACqC,WAAW,CAACD,IAAI,CAAC;EACtB,OAAOA,IAAI;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAtC,QAAQ,CAACmC,SAAS,CAACI,WAAW,GAAG,UAAUC,SAAS,EAAE;EAElD,IAAIA,SAAS,CAAC1B,QAAQ,KAAK,IAAI,CAACA,QAAQ,EAAE;IACtC0B,SAAS,CAAC1B,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAClC0B,SAAS,CAACb,OAAO,GAAG,EAAE,IAAI,CAACb,QAAQ,CAACX,WAAW;EACnD;EAEAqC,SAAS,CAAChB,UAAU,GAAG,IAAI;EAE3B,IAAI,CAACE,UAAU,CAACe,IAAI,CAACD,SAAS,CAAC;EAC/B,OAAOA,SAAS;AACpB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAxC,QAAQ,CAACmC,SAAS,CAACO,OAAO,GAAG,UAAUJ,IAAI,EAAE;EACzC,IAAIA,IAAI,KAAK,IAAI,EAAE;IACf,OAAO,IAAI;EACf;EAEA,IAAI,CAACd,UAAU,CAACE,UAAU,CAACiB,OAAO,CAAC,UAAUH,SAAS,EAAEI,CAAC,EAAE;IACvD,IAAIJ,SAAS,KAAK,IAAI,EAAE;MAEpBF,IAAI,CAACxB,QAAQ,GAAG,IAAI,CAACA,QAAQ;MAC7BwB,IAAI,CAACd,UAAU,GAAG,IAAI,CAACA,UAAU;MACjCc,IAAI,CAACX,OAAO,GAAG,IAAI,CAACA,OAAO;MAE3B,IAAI,CAACb,QAAQ,GAAG,IAAI;MACpB,IAAI,CAACU,UAAU,GAAGa,SAAS;MAE3BC,IAAI,CAACd,UAAU,CAACE,UAAU,CAACkB,CAAC,CAAC,GAAGN,IAAI;IACxC;EACJ,CAAC,CAACO,IAAI,CAAC,IAAI,CAAC,CAAC;EAEb,OAAOP,IAAI;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAtC,QAAQ,CAACmC,SAAS,CAACW,MAAM,GAAG,YAAY;EACpC,IAAI,CAAC,IAAI,CAACtB,UAAU,EAAE;IAClB,OAAO,IAAI;EACf;EAEA,KAAK,IAAIoB,CAAC,GAAG,IAAI,CAACpB,UAAU,CAACE,UAAU,CAACqB,MAAM,GAAG,CAAC,EAAEH,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC7D,IAAI,IAAI,CAACpB,UAAU,CAACE,UAAU,CAACkB,CAAC,CAAC,KAAK,IAAI,EAAE;MACxC,IAAI,CAACpB,UAAU,CAACE,UAAU,CAACsB,MAAM,CAACJ,CAAC,EAAE,CAAC,CAAC;MACvC,IAAI,CAACpB,UAAU,GAAGa,SAAS;MAC3B,IAAI,CAACvB,QAAQ,GAAG,IAAI;MACpB,OAAO,IAAI;IACf;EACJ;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAd,QAAQ,CAACmC,SAAS,CAACD,SAAS,GAAG,UAAUe,GAAG,EAAEC,KAAK,EAAE;EACjD,IAAIC,KAAK,GAAG,KAAK;IACbC,WAAW;;EAEf;EACA,IAAI,CAACF,KAAK,IAAID,GAAG,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IAC1C;IACA,IAAIA,GAAG,CAACA,GAAG,IAAI,OAAO,IAAIA,GAAG,EAAE;MAC3B,IAAI,CAACf,SAAS,CAACe,GAAG,CAACA,GAAG,EAAEA,GAAG,CAACC,KAAK,CAAC;IACtC;IACA;IAAA,KACK,IAAIG,KAAK,CAACC,OAAO,CAACL,GAAG,CAAC,EAAE;MACzBA,GAAG,CAACN,OAAO,CAAC,UAAUC,CAAC,EAAE;QACrB,IAAI,CAACV,SAAS,CAACU,CAAC,CAACK,GAAG,EAAEL,CAAC,CAACM,KAAK,CAAC;MAClC,CAAC,CAACL,IAAI,CAAC,IAAI,CAAC,CAAC;IACjB;IACA;IAAA,KACK;MACDU,MAAM,CAACC,IAAI,CAACP,GAAG,CAAC,CAACN,OAAO,CAAC,UAAUC,CAAC,EAAE;QAClC,IAAI,CAACV,SAAS,CAACU,CAAC,EAAEK,GAAG,CAACL,CAAC,CAAC,CAAC;MAC7B,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;IACjB;IACA,OAAO,IAAI;EACf;EAEAI,GAAG,GAAG,IAAI,CAACQ,mBAAmB,CAACR,GAAG,CAAC;EAEnCG,WAAW,GAAG;IACVH,GAAG,EAAEA,GAAG;IACRC,KAAK,EAAEA;EACX,CAAC;;EAED;EACA,KAAK,IAAIN,CAAC,GAAG,CAAC,EAAEc,GAAG,GAAG,IAAI,CAAC9B,QAAQ,CAACmB,MAAM,EAAEH,CAAC,GAAGc,GAAG,EAAEd,CAAC,EAAE,EAAE;IACtD,IAAI,IAAI,CAAChB,QAAQ,CAACgB,CAAC,CAAC,CAACK,GAAG,KAAKA,GAAG,EAAE;MAC9B,IAAI,CAACE,KAAK,EAAE;QACR;QACA,IAAI,CAACvB,QAAQ,CAACgB,CAAC,CAAC,GAAGQ,WAAW;QAC9BD,KAAK,GAAG,IAAI;MAChB,CAAC,MAAM;QACH;QACA,IAAI,CAACvB,QAAQ,CAACoB,MAAM,CAACJ,CAAC,EAAE,CAAC,CAAC;QAC1BA,CAAC,EAAE;QACHc,GAAG,EAAE;MACT;IACJ;EACJ;;EAEA;EACA,IAAI,CAACP,KAAK,EAAE;IACR,IAAI,CAACvB,QAAQ,CAACa,IAAI,CAACW,WAAW,CAAC;EACnC;EAEA,OAAO,IAAI;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACApD,QAAQ,CAACmC,SAAS,CAACwB,SAAS,GAAG,UAAUV,GAAG,EAAEC,KAAK,EAAE;EAEjD;EACA,IAAI,CAACA,KAAK,IAAID,GAAG,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IAC1C;IACA,IAAIA,GAAG,CAACA,GAAG,IAAIA,GAAG,CAACC,KAAK,EAAE;MACtB,IAAI,CAACS,SAAS,CAACV,GAAG,CAACA,GAAG,EAAEA,GAAG,CAACC,KAAK,CAAC;IACtC;IACA;IAAA,KACK,IAAIG,KAAK,CAACC,OAAO,CAACL,GAAG,CAAC,EAAE;MACzBA,GAAG,CAACN,OAAO,CAAC,UAAUC,CAAC,EAAE;QACrB,IAAI,CAACe,SAAS,CAACf,CAAC,CAACK,GAAG,EAAEL,CAAC,CAACM,KAAK,CAAC;MAClC,CAAC,CAACL,IAAI,CAAC,IAAI,CAAC,CAAC;IACjB;IACA;IAAA,KACK;MACDU,MAAM,CAACC,IAAI,CAACP,GAAG,CAAC,CAACN,OAAO,CAAC,UAAUC,CAAC,EAAE;QAClC,IAAI,CAACe,SAAS,CAACf,CAAC,EAAEK,GAAG,CAACL,CAAC,CAAC,CAAC;MAC7B,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;IACjB;IACA,OAAO,IAAI;EACf,CAAC,MAAM,IAAIQ,KAAK,CAACC,OAAO,CAACJ,KAAK,CAAC,EAAE;IAC7BA,KAAK,CAACP,OAAO,CAAC,UAAUiB,GAAG,EAAE;MACzB,IAAI,CAACD,SAAS,CAACV,GAAG,EAAEW,GAAG,CAAC;IAC5B,CAAC,CAACf,IAAI,CAAC,IAAI,CAAC,CAAC;IACb,OAAO,IAAI;EACf;EAEA,IAAI,CAACjB,QAAQ,CAACa,IAAI,CAAC;IACfQ,GAAG,EAAE,IAAI,CAACQ,mBAAmB,CAACR,GAAG,CAAC;IAClCC,KAAK,EAAEA;EACX,CAAC,CAAC;EAEF,OAAO,IAAI;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAlD,QAAQ,CAACmC,SAAS,CAAC0B,SAAS,GAAG,UAAUZ,GAAG,EAAE;EAC1CA,GAAG,GAAG,IAAI,CAACQ,mBAAmB,CAACR,GAAG,CAAC;EACnC,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEc,GAAG,GAAG,IAAI,CAAC9B,QAAQ,CAACmB,MAAM,EAAEH,CAAC,GAAGc,GAAG,EAAEd,CAAC,EAAE,EAAE;IACtD,IAAI,IAAI,CAAChB,QAAQ,CAACgB,CAAC,CAAC,CAACK,GAAG,KAAKA,GAAG,EAAE;MAC9B,OAAO,IAAI,CAACrB,QAAQ,CAACgB,CAAC,CAAC,CAACM,KAAK;IACjC;EACJ;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlD,QAAQ,CAACmC,SAAS,CAAC2B,UAAU,GAAG,UAAUC,OAAO,EAAE;EAC/C,IAAIC,KAAK,GAAG,IAAI;EAChB,IAAI,CAACD,OAAO,GAAGA,OAAO;EACtB,IAAI,OAAO,IAAI,CAACA,OAAO,CAACE,IAAI,KAAK,UAAU,EAAE;IACzC;IACA;IACA,IAAI,CAACC,oBAAoB,GAAG,UAAUC,GAAG,EAAE;MACvCH,KAAK,CAACD,OAAO,CAACK,cAAc,CAAC,OAAO,EAAEJ,KAAK,CAACE,oBAAoB,CAAC;MACjEF,KAAK,CAACD,OAAO,GAAGI,GAAG;IACvB,CAAC;IACD,IAAI,CAACJ,OAAO,CAACM,IAAI,CAAC,OAAO,EAAE,IAAI,CAACH,oBAAoB,CAAC;EACzD,CAAC,MAAM,IAAI,OAAO,IAAI,CAACH,OAAO,KAAK,QAAQ,EAAE;IACzC,IAAI,CAAClC,YAAY,GAAG3C,OAAO,CAACoF,WAAW,CAAC,IAAI,CAACP,OAAO,CAAC;IACrD,IAAI,IAAI,CAAClC,YAAY,IAAI3C,OAAO,CAACqF,cAAc,CAAC,IAAI,CAACR,OAAO,EAAE,EAAE,CAAC,EAAE;MAC/D;MACA,IAAI,CAACjC,aAAa,GAAG,IAAI;IAC7B;EACJ;EACA,OAAO,IAAI;AACf,CAAC;AAED9B,QAAQ,CAACmC,SAAS,CAACqC,KAAK,GAAG,UAAUC,QAAQ,EAAE;EAC3C,IAAIjF,MAAM,GAAG,IAAI,CAACkF,gBAAgB,CAAC,CAAC;EACpC,IAAIC,GAAG,GAAG,EAAE;EACZ,IAAIC,MAAM,GAAG,CAAC;EACd,IAAIC,QAAQ,GAAG,KAAK;EAEpBrF,MAAM,CAACsF,EAAE,CAAC,UAAU,EAAE,YAAY;IAC9B,IAAIC,KAAK;IAET,OAAO,CAACA,KAAK,GAAGvF,MAAM,CAACwF,IAAI,CAAC,CAAC,MAAM,IAAI,EAAE;MACrCL,GAAG,CAAClC,IAAI,CAACsC,KAAK,CAAC;MACfH,MAAM,IAAIG,KAAK,CAAChC,MAAM;IAC1B;EACJ,CAAC,CAAC;EAEFvD,MAAM,CAAC6E,IAAI,CAAC,OAAO,EAAE,UAAUF,GAAG,EAAE;IAChC,IAAIU,QAAQ,EAAE;MACV;IACJ;IACAA,QAAQ,GAAG,IAAI;IAEf,OAAOJ,QAAQ,CAACN,GAAG,CAAC;EACxB,CAAC,CAAC;EAEF3E,MAAM,CAAC6E,IAAI,CAAC,KAAK,EAAE,UAAUU,KAAK,EAAE;IAChC,IAAIF,QAAQ,EAAE;MACV;IACJ;IACAA,QAAQ,GAAG,IAAI;IAEf,IAAIE,KAAK,IAAIA,KAAK,CAAChC,MAAM,EAAE;MACvB4B,GAAG,CAAClC,IAAI,CAACsC,KAAK,CAAC;MACfH,MAAM,IAAIG,KAAK,CAAChC,MAAM;IAC1B;IACA,OAAO0B,QAAQ,CAAC,IAAI,EAAEQ,MAAM,CAACC,MAAM,CAACP,GAAG,EAAEC,MAAM,CAAC,CAAC;EACrD,CAAC,CAAC;AACN,CAAC;AAED5E,QAAQ,CAACmC,SAAS,CAACgD,mBAAmB,GAAG,YAAY;EACjD,IAAIC,gBAAgB,GAAG,KAAK;EAC5B,IAAInF,WAAW,GAAG,CAAC,IAAI,CAAC4D,SAAS,CAAC,cAAc,CAAC,IAAI,EAAE,EAAEtD,QAAQ,CAAC,CAAC,CAAC8E,WAAW,CAAC,CAAC,CAAChE,IAAI,CAAC,CAAC;EAExF,IAAI,IAAI,CAAC0C,OAAO,EAAE;IACdqB,gBAAgB,GAAG,CAAC,IAAI,CAACvB,SAAS,CAAC,2BAA2B,CAAC,IAAI,EAAE,EAAEtD,QAAQ,CAAC,CAAC,CAAC8E,WAAW,CAAC,CAAC,CAAChE,IAAI,CAAC,CAAC;IACtG,IAAI,CAAC+D,gBAAgB,IAAI,CAAC,QAAQ,EAAE,kBAAkB,CAAC,CAACE,OAAO,CAACF,gBAAgB,CAAC,GAAG,CAAC,EAAE;MACnF,IAAI,UAAU,CAACG,IAAI,CAACtF,WAAW,CAAC,EAAE;QAC9B;QACA,IAAI,IAAI,CAAC4B,YAAY,IAAI,CAAC,IAAI,CAACC,aAAa,EAAE;UAC1CsD,gBAAgB,GAAG,MAAM;QAC7B,CAAC,MAAM,IAAI,OAAO,IAAI,CAACrB,OAAO,KAAK,QAAQ,IAAI,IAAI,CAACA,OAAO,YAAYkB,MAAM,EAAE;UAC3E;UACAG,gBAAgB,GAAG,IAAI,CAACI,gBAAgB,CAAC,IAAI,CAACzB,OAAO,CAAC,KAAK,GAAG,GAAG,kBAAkB,GAAG,QAAQ;QAClG,CAAC,MAAM;UACH;UACAqB,gBAAgB,GAAG,IAAI,CAACA,gBAAgB,KAAK,GAAG,GAAG,QAAQ,GAAG,kBAAkB;QACpF;MACJ,CAAC,MAAM,IAAI,CAAC,yBAAyB,CAACG,IAAI,CAACtF,WAAW,CAAC,EAAE;QACrDmF,gBAAgB,GAAGA,gBAAgB,IAAI,QAAQ;MACnD;IACJ;EACJ;EACA,OAAOA,gBAAgB;AAC3B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACApF,QAAQ,CAACmC,SAAS,CAACsD,YAAY,GAAG,YAAY;EAC1C,IAAIzB,KAAK,GAAG,IAAI;EAChB,IAAIoB,gBAAgB,GAAG,IAAI,CAACD,mBAAmB,CAAC,CAAC;EACjD,IAAIO,OAAO,GAAG,EAAE;EAEhB,IAAIN,gBAAgB,EAAE;IAClB,IAAI,CAAClD,SAAS,CAAC,2BAA2B,EAAEkD,gBAAgB,CAAC;EACjE;EAEA,IAAI,IAAI,CAACpE,QAAQ,IAAI,CAAC,IAAI,CAAC6C,SAAS,CAAC,qBAAqB,CAAC,EAAE;IACzD,IAAI,CAAC3B,SAAS,CAAC,qBAAqB,EAAE,YAAY,CAAC;EACvD;;EAEA;EACA,IAAI,IAAI,CAACpB,QAAQ,KAAK,IAAI,EAAE;IACxB,IAAI,CAAC,IAAI,CAAC+C,SAAS,CAAC,MAAM,CAAC,EAAE;MACzB,IAAI,CAAC3B,SAAS,CAAC,MAAM,EAAE,IAAI,CAACrB,IAAI,CAAC8E,WAAW,CAAC,CAAC,CAACjD,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;IAC3E;;IAEA;IACA,IAAI,CAACkD,SAAS,CAAC,CAAC;IAEhB,IAAI,CAAC,IAAI,CAAC/B,SAAS,CAAC,cAAc,CAAC,EAAE;MACjC,IAAI,CAAC3B,SAAS,CAAC,cAAc,EAAE,KAAK,CAAC;IACzC;EACJ;EAEA,IAAI,CAACN,QAAQ,CAACe,OAAO,CAAC,UAAUkD,MAAM,EAAE;IACpC,IAAI5C,GAAG,GAAG4C,MAAM,CAAC5C,GAAG;IACpB,IAAIC,KAAK,GAAG2C,MAAM,CAAC3C,KAAK;IACxB,IAAI4C,UAAU;IACd,IAAIC,KAAK;IACT,IAAI7F,OAAO,GAAG,CAAC,CAAC;IAChB,IAAI8F,gBAAgB,GAAG,CAAC,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,MAAM,EAAE,YAAY,CAAC;IAE9F,IAAI9C,KAAK,IAAI8C,gBAAgB,CAACV,OAAO,CAACrC,GAAG,CAAC,GAAG,CAAC,IAAI,OAAOC,KAAK,KAAK,QAAQ,EAAE;MACzEK,MAAM,CAACC,IAAI,CAACN,KAAK,CAAC,CAACP,OAAO,CAAC,UAAUM,GAAG,EAAE;QACtC,IAAIA,GAAG,KAAK,OAAO,EAAE;UACjB/C,OAAO,CAAC+C,GAAG,CAAC,GAAGC,KAAK,CAACD,GAAG,CAAC;QAC7B;MACJ,CAAC,CAAC;MACFC,KAAK,GAAG,CAACA,KAAK,CAACA,KAAK,IAAI,EAAE,EAAE3C,QAAQ,CAAC,CAAC;MACtC,IAAI,CAAC2C,KAAK,CAAC7B,IAAI,CAAC,CAAC,EAAE;QACf;MACJ;IACJ;IAEA,IAAInB,OAAO,CAAC+F,QAAQ,EAAE;MAClB;MACAP,OAAO,CAACjD,IAAI,CAACQ,GAAG,GAAG,IAAI,GAAGC,KAAK,CAAC;MAChC;IACJ;IAEA,QAAQ2C,MAAM,CAAC5C,GAAG;MACd,KAAK,qBAAqB;QACtB6C,UAAU,GAAG5G,OAAO,CAACgH,gBAAgB,CAAChD,KAAK,CAAC;QAC5C,IAAIc,KAAK,CAAChD,QAAQ,EAAE;UAChB8E,UAAU,CAACK,MAAM,CAACnF,QAAQ,GAAGgD,KAAK,CAAChD,QAAQ;QAC/C;QACAkC,KAAK,GAAGhE,OAAO,CAACkH,gBAAgB,CAACN,UAAU,CAAC;QAC5C;MACJ,KAAK,cAAc;QACfA,UAAU,GAAG5G,OAAO,CAACgH,gBAAgB,CAAChD,KAAK,CAAC;QAE5Cc,KAAK,CAACqC,kBAAkB,CAACP,UAAU,CAAC;QAEpC,IAAIA,UAAU,CAAC5C,KAAK,CAACoD,KAAK,CAAC,gBAAgB,CAAC,IAAI,OAAOtC,KAAK,CAACD,OAAO,KAAK,QAAQ,IAAI,iBAAiB,CAACwB,IAAI,CAACvB,KAAK,CAACD,OAAO,CAAC,EAAE;UACxH+B,UAAU,CAACK,MAAM,CAACI,OAAO,GAAG,OAAO;QACvC;QAEArD,KAAK,GAAGhE,OAAO,CAACkH,gBAAgB,CAACN,UAAU,CAAC;QAE5C,IAAI9B,KAAK,CAAChD,QAAQ,EAAE;UAChB;UACA;UACA;UACA+E,KAAK,GAAG,IAAI,CAACS,YAAY,CAACxC,KAAK,CAAChD,QAAQ,CAAC;UACzC,IAAI+E,KAAK,KAAK/B,KAAK,CAAChD,QAAQ,IAAI,SAAS,CAACuE,IAAI,CAACQ,KAAK,CAAC,EAAE;YACnD;YACAA,KAAK,GAAG,GAAG,GAAGA,KAAK,GAAG,GAAG;UAC7B;UACA7C,KAAK,IAAI,SAAS,GAAG6C,KAAK;QAC9B;QACA;MACJ,KAAK,KAAK;QACN,IAAI,CAAC/B,KAAK,CAACjD,OAAO,EAAE;UAChB;UACA;QACJ;QACA;IACR;IAEAmC,KAAK,GAAGc,KAAK,CAACyC,kBAAkB,CAACxD,GAAG,EAAEC,KAAK,CAAC;;IAE5C;IACA,IAAI,CAAC,CAACA,KAAK,IAAI,EAAE,EAAE3C,QAAQ,CAAC,CAAC,CAACc,IAAI,CAAC,CAAC,EAAE;MAClC;IACJ;IAEAqE,OAAO,CAACjD,IAAI,CAACvD,OAAO,CAACwH,SAAS,CAACzD,GAAG,GAAG,IAAI,GAAGC,KAAK,EAAE,EAAE,CAAC,CAAC;EAC3D,CAAC,CAACL,IAAI,CAAC,IAAI,CAAC,CAAC;EAEb,OAAO6C,OAAO,CAACiB,IAAI,CAAC,MAAM,CAAC;AAC/B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA3G,QAAQ,CAACmC,SAAS,CAACuC,gBAAgB,GAAG,UAAUxE,OAAO,EAAE;EACrDA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EAEvB,IAAI0G,YAAY,GAAG,IAAInH,WAAW,CAACS,OAAO,CAAC;EAC3C,IAAI2G,SAAS;EAEb,IAAI,CAACrH,MAAM,CAACoH,YAAY,EAAE1G,OAAO,EAAE,UAAUiE,GAAG,EAAE;IAC9C,IAAIA,GAAG,EAAE;MACLyC,YAAY,CAACE,IAAI,CAAC,OAAO,EAAE3C,GAAG,CAAC;MAC/B;IACJ;IACAyC,YAAY,CAACG,GAAG,CAAC,CAAC;EACtB,CAAC,CAAC;EAEF,KAAK,IAAInE,CAAC,GAAG,CAAC,EAAEc,GAAG,GAAG,IAAI,CAACzB,WAAW,CAACc,MAAM,EAAEH,CAAC,GAAGc,GAAG,EAAEd,CAAC,EAAE,EAAE;IACzDiE,SAAS,GAAG,OAAO,IAAI,CAAC5E,WAAW,CAACW,CAAC,CAAC,KAAK,UAAU,GAAG,IAAI,CAACX,WAAW,CAACW,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAACX,WAAW,CAACW,CAAC,CAAC;IACnGgE,YAAY,CAACvC,IAAI,CAAC,OAAO,EAAE,UAAUF,GAAG,EAAE;MACtC0C,SAAS,CAACC,IAAI,CAAC,OAAO,EAAE3C,GAAG,CAAC;IAChC,CAAC,CAAC;IACFyC,YAAY,GAAGA,YAAY,CAAC3C,IAAI,CAAC4C,SAAS,CAAC;EAC/C;EAEA,OAAOD,YAAY;AACvB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA5G,QAAQ,CAACmC,SAAS,CAAC0E,SAAS,GAAG,UAAUA,SAAS,EAAE;EAChD,IAAI,CAAC5E,WAAW,CAACQ,IAAI,CAACoE,SAAS,CAAC;AACpC,CAAC;AAED7G,QAAQ,CAACmC,SAAS,CAAC3C,MAAM,GAAG,UAAUoH,YAAY,EAAE1G,OAAO,EAAE8G,IAAI,EAAE;EAC/D,IAAIhD,KAAK,GAAG,IAAI;EAChB,IAAIoB,gBAAgB,GAAG,IAAI,CAACD,mBAAmB,CAAC,CAAC;EACjD,IAAI8B,aAAa;EACjB,IAAIC,WAAW;;EAEf;EACA,IAAIrC,QAAQ,GAAG,KAAK;EACpB,IAAIJ,QAAQ,GAAG,SAAAA,CAAUN,GAAG,EAAE;IAC1B,IAAIU,QAAQ,EAAE;MACV;IACJ;IACAA,QAAQ,GAAG,IAAI;IACfmC,IAAI,CAAC7C,GAAG,CAAC;EACb,CAAC;;EAED;EACA,SAASgD,WAAWA,CAAA,EAAG;IACnB,IAAInD,KAAK,CAACD,OAAO,EAAE;MAEf,IAAIR,MAAM,CAACpB,SAAS,CAAC5B,QAAQ,CAAC6G,IAAI,CAACpD,KAAK,CAACD,OAAO,CAAC,KAAK,gBAAgB,EAAE;QACpE;QACA,OAAOU,QAAQ,CAACT,KAAK,CAACD,OAAO,CAAC;MAClC;MAEA,IAAI,OAAOC,KAAK,CAACD,OAAO,CAACE,IAAI,KAAK,UAAU,EAAE;QAC1CD,KAAK,CAACD,OAAO,CAACK,cAAc,CAAC,OAAO,EAAEJ,KAAK,CAACE,oBAAoB,CAAC;QACjEF,KAAK,CAACE,oBAAoB,GAAG,UAAUC,GAAG,EAAE;UACxC,OAAOM,QAAQ,CAACN,GAAG,CAAC;QACxB,CAAC;QACDH,KAAK,CAACD,OAAO,CAACM,IAAI,CAAC,OAAO,EAAEL,KAAK,CAACE,oBAAoB,CAAC;MAC3D;MAEA,IAAI,CAAC,kBAAkB,EAAE,QAAQ,CAAC,CAACoB,OAAO,CAACF,gBAAgB,CAAC,IAAI,CAAC,EAAE;QAC/D6B,aAAa,GAAG,IAAG,CAAC7B,gBAAgB,KAAK,QAAQ,GAAG/F,SAAS,GAAGD,KAAK,EAAEiI,OAAO,CAACnH,OAAO,CAAC;QAEvF+G,aAAa,CAAChD,IAAI,CAAC2C,YAAY,EAAE;UAC7BG,GAAG,EAAE;QACT,CAAC,CAAC;QACFE,aAAa,CAAC5C,IAAI,CAAC,KAAK,EAAEiD,QAAQ,CAAC;QACnCL,aAAa,CAAC5C,IAAI,CAAC,OAAO,EAAE,UAAUF,GAAG,EAAE;UACvC,OAAOM,QAAQ,CAACN,GAAG,CAAC;QACxB,CAAC,CAAC;QAEF+C,WAAW,GAAGlD,KAAK,CAACuD,UAAU,CAACvD,KAAK,CAACD,OAAO,CAAC;QAC7CmD,WAAW,CAACjD,IAAI,CAACgD,aAAa,CAAC;MACnC,CAAC,MAAM;QACH;QACAC,WAAW,GAAGlD,KAAK,CAACuD,UAAU,CAACvD,KAAK,CAACD,OAAO,CAAC;QAC7CmD,WAAW,CAACjD,IAAI,CAAC2C,YAAY,EAAE;UAC3BG,GAAG,EAAE;QACT,CAAC,CAAC;QACFG,WAAW,CAAC7C,IAAI,CAAC,KAAK,EAAEiD,QAAQ,CAAC;MACrC;MAEAJ,WAAW,CAAC7C,IAAI,CAAC,OAAO,EAAE,UAAUF,GAAG,EAAE;QACrC,OAAOM,QAAQ,CAACN,GAAG,CAAC;MACxB,CAAC,CAAC;MAEF;IACJ,CAAC,MAAM;MACH,OAAOqD,YAAY,CAACF,QAAQ,CAAC;IACjC;EACJ;;EAEA;EACA;EACA,SAASA,QAAQA,CAAA,EAAG;IAChB,IAAIG,OAAO,GAAG,CAAC;IACf,IAAIC,gBAAgB,GAAG,SAAAA,CAAA,EAAY;MAC/B,IAAID,OAAO,IAAIzD,KAAK,CAACtC,UAAU,CAACqB,MAAM,EAAE;QACpC6D,YAAY,CAACe,KAAK,CAAC,QAAQ,GAAG3D,KAAK,CAAC4D,QAAQ,GAAG,QAAQ,CAAC;QACxD,OAAOnD,QAAQ,CAAC,CAAC;MACrB;MACA,IAAIoD,KAAK,GAAG7D,KAAK,CAACtC,UAAU,CAAC+F,OAAO,EAAE,CAAC;MACvCb,YAAY,CAACe,KAAK,CAAC,CAACF,OAAO,GAAG,CAAC,GAAG,MAAM,GAAG,EAAE,IAAI,IAAI,GAAGzD,KAAK,CAAC4D,QAAQ,GAAG,MAAM,CAAC;MAChFC,KAAK,CAACrI,MAAM,CAACoH,YAAY,EAAE1G,OAAO,EAAE,UAAUiE,GAAG,EAAE;QAC/C,IAAIA,GAAG,EAAE;UACL,OAAOM,QAAQ,CAACN,GAAG,CAAC;QACxB;QACAqD,YAAY,CAACE,gBAAgB,CAAC;MAClC,CAAC,CAAC;IACN,CAAC;IAED,IAAI1D,KAAK,CAAC8D,SAAS,EAAE;MACjBN,YAAY,CAACE,gBAAgB,CAAC;IAClC,CAAC,MAAM;MACH,OAAOjD,QAAQ,CAAC,CAAC;IACrB;EACJ;EAEA,IAAI,IAAI,CAACzC,IAAI,EAAE;IACXwF,YAAY,CAAC,YAAY;MACrB,IAAIjE,MAAM,CAACpB,SAAS,CAAC5B,QAAQ,CAAC6G,IAAI,CAACpD,KAAK,CAAChC,IAAI,CAAC,KAAK,gBAAgB,EAAE;QACjE;QACA,OAAOyC,QAAQ,CAACT,KAAK,CAAChC,IAAI,CAAC;MAC/B;;MAEA;MACA,IAAI,OAAOgC,KAAK,CAAChC,IAAI,CAACiC,IAAI,KAAK,UAAU,EAAE;QACvCD,KAAK,CAAChC,IAAI,CAACoC,cAAc,CAAC,OAAO,EAAEJ,KAAK,CAACE,oBAAoB,CAAC;MAClE;MAEA,IAAI6D,GAAG,GAAG/D,KAAK,CAACuD,UAAU,CAACvD,KAAK,CAAChC,IAAI,CAAC;MACtC+F,GAAG,CAAC9D,IAAI,CAAC2C,YAAY,EAAE;QACnBG,GAAG,EAAE;MACT,CAAC,CAAC;MACFgB,GAAG,CAACjD,EAAE,CAAC,OAAO,EAAE,UAAUX,GAAG,EAAE;QAC3ByC,YAAY,CAACE,IAAI,CAAC,OAAO,EAAE3C,GAAG,CAAC;MACnC,CAAC,CAAC;MACF4D,GAAG,CAACjD,EAAE,CAAC,KAAK,EAAEwC,QAAQ,CAAC;IAC3B,CAAC,CAAC;EACN,CAAC,MAAM;IACHV,YAAY,CAACe,KAAK,CAAC,IAAI,CAAClC,YAAY,CAAC,CAAC,GAAG,UAAU,CAAC;IACpD+B,YAAY,CAACL,WAAW,CAAC;EAC7B;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAnH,QAAQ,CAACmC,SAAS,CAAC6F,WAAW,GAAG,UAAUC,QAAQ,EAAE;EACjD,IAAIC,IAAI;EAER,IAAI,CAACnG,SAAS,GAAG;IACboG,IAAI,EAAE,KAAK;IACXC,EAAE,EAAE;EACR,CAAC;EAED,IAAIH,QAAQ,CAACE,IAAI,EAAE;IACfD,IAAI,GAAG,EAAE;IACT,IAAI,CAACG,iBAAiB,CAAC,IAAI,CAACC,eAAe,CAACL,QAAQ,CAACE,IAAI,CAAC,EAAED,IAAI,CAAC;IACjEA,IAAI,GAAGA,IAAI,CAACK,MAAM,CAAC,UAAUC,OAAO,EAAE;MAClC,OAAOA,OAAO,IAAIA,OAAO,CAACA,OAAO;IACrC,CAAC,CAAC;IACF,IAAIN,IAAI,CAACnF,MAAM,IAAImF,IAAI,CAAC,CAAC,CAAC,EAAE;MACxB,IAAI,CAACnG,SAAS,CAACoG,IAAI,GAAGD,IAAI,CAAC,CAAC,CAAC,CAACM,OAAO;IACzC;EACJ;EACA,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC7F,OAAO,CAAC,UAAUM,GAAG,EAAE;IACvC,IAAIgF,QAAQ,CAAChF,GAAG,CAAC,EAAE;MACf,IAAI,CAACoF,iBAAiB,CAAC,IAAI,CAACC,eAAe,CAACL,QAAQ,CAAChF,GAAG,CAAC,CAAC,EAAE,IAAI,CAAClB,SAAS,CAACqG,EAAE,CAAC;IAClF;EACJ,CAAC,CAACvF,IAAI,CAAC,IAAI,CAAC,CAAC;EAEb,IAAI,CAACd,SAAS,CAACqG,EAAE,GAAG,IAAI,CAACrG,SAAS,CAACqG,EAAE,CAACK,GAAG,CAAC,UAAUL,EAAE,EAAE;IACpD,OAAOA,EAAE,CAACI,OAAO;EACrB,CAAC,CAAC,CAACD,MAAM,CAAC,UAAUC,OAAO,EAAE;IACzB,OAAOA,OAAO;EAClB,CAAC,CAAC;EAEF,OAAO,IAAI;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAxI,QAAQ,CAACmC,SAAS,CAACuG,YAAY,GAAG,YAAY;EAC1C,IAAIC,SAAS,GAAG,CAAC,CAAC;EAElB,IAAI,CAAC/G,QAAQ,CAACe,OAAO,CAAC,UAAUkD,MAAM,EAAE;IACpC,IAAI5C,GAAG,GAAG4C,MAAM,CAAC5C,GAAG,CAACoC,WAAW,CAAC,CAAC;IAClC,IAAI,CAAC,MAAM,EAAE,QAAQ,EAAE,UAAU,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAACC,OAAO,CAACrC,GAAG,CAAC,IAAI,CAAC,EAAE;MACrE,IAAI,CAACI,KAAK,CAACC,OAAO,CAACqF,SAAS,CAAC1F,GAAG,CAAC,CAAC,EAAE;QAChC0F,SAAS,CAAC1F,GAAG,CAAC,GAAG,EAAE;MACvB;MAEA,IAAI,CAACoF,iBAAiB,CAAC,IAAI,CAACC,eAAe,CAACzC,MAAM,CAAC3C,KAAK,CAAC,EAAEyF,SAAS,CAAC1F,GAAG,CAAC,CAAC;IAC9E;EACJ,CAAC,CAACJ,IAAI,CAAC,IAAI,CAAC,CAAC;EAEb,OAAO8F,SAAS;AACpB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA3I,QAAQ,CAACmC,SAAS,CAACyG,WAAW,GAAG,YAAY;EACzC,IAAI,IAAI,CAAC7G,SAAS,EAAE;IAChB,OAAO,IAAI,CAACA,SAAS;EACzB;EAEA,IAAIkG,QAAQ,GAAG;IACXE,IAAI,EAAE,KAAK;IACXC,EAAE,EAAE;EACR,CAAC;EACD,IAAI,CAACxG,QAAQ,CAACe,OAAO,CAAC,UAAUkD,MAAM,EAAE;IACpC,IAAIqC,IAAI,GAAG,EAAE;IACb,IAAIrC,MAAM,CAAC5C,GAAG,KAAK,MAAM,IAAK,CAACgF,QAAQ,CAACE,IAAI,IAAI,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC7C,OAAO,CAACO,MAAM,CAAC5C,GAAG,CAAC,IAAI,CAAE,EAAE;MAC9F,IAAI,CAACoF,iBAAiB,CAAC,IAAI,CAACC,eAAe,CAACzC,MAAM,CAAC3C,KAAK,CAAC,EAAEgF,IAAI,CAAC;MAChE,IAAIA,IAAI,CAACnF,MAAM,IAAImF,IAAI,CAAC,CAAC,CAAC,EAAE;QACxBD,QAAQ,CAACE,IAAI,GAAGD,IAAI,CAAC,CAAC,CAAC,CAACM,OAAO;MACnC;IACJ,CAAC,MAAM,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAAClD,OAAO,CAACO,MAAM,CAAC5C,GAAG,CAAC,IAAI,CAAC,EAAE;MACrD,IAAI,CAACoF,iBAAiB,CAAC,IAAI,CAACC,eAAe,CAACzC,MAAM,CAAC3C,KAAK,CAAC,EAAE+E,QAAQ,CAACG,EAAE,CAAC;IAC3E;EACJ,CAAC,CAACvF,IAAI,CAAC,IAAI,CAAC,CAAC;EAEboF,QAAQ,CAACG,EAAE,GAAGH,QAAQ,CAACG,EAAE,CAACK,GAAG,CAAC,UAAUL,EAAE,EAAE;IACxC,OAAOA,EAAE,CAACI,OAAO;EACrB,CAAC,CAAC;EAEF,OAAOP,QAAQ;AACnB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAjI,QAAQ,CAACmC,SAAS,CAACyD,SAAS,GAAG,YAAY;EACvC,IAAIA,SAAS,GAAG,IAAI,CAAC/B,SAAS,CAAC,YAAY,CAAC;EAC5C;EACA,IAAI,CAAC+B,SAAS,EAAE;IACZA,SAAS,GAAG,IAAI,CAACiD,kBAAkB,CAAC,CAAC;IACrC,IAAI,CAAC3G,SAAS,CAAC,YAAY,EAAE0D,SAAS,CAAC;EAC3C;EACA,OAAOA,SAAS;AACpB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA5F,QAAQ,CAACmC,SAAS,CAAC2G,MAAM,GAAG,UAAUf,GAAG,EAAE;EACvC,IAAI/D,KAAK,GAAG,IAAI;EAEhB,IAAI,CAAChC,IAAI,GAAG+F,GAAG;EAEf,IAAI,IAAI,CAAC/F,IAAI,IAAI,OAAO,IAAI,CAACA,IAAI,CAACiC,IAAI,KAAK,UAAU,EAAE;IACnD;IACA;IACA,IAAI,CAACC,oBAAoB,GAAG,UAAUC,GAAG,EAAE;MACvCH,KAAK,CAAChC,IAAI,CAACoC,cAAc,CAAC,OAAO,EAAEJ,KAAK,CAACE,oBAAoB,CAAC;MAC9DF,KAAK,CAAChC,IAAI,GAAGmC,GAAG;IACpB,CAAC;IACDH,KAAK,CAAChC,IAAI,CAACqC,IAAI,CAAC,OAAO,EAAE,IAAI,CAACH,oBAAoB,CAAC;EACvD;EAEA,OAAO,IAAI;AACf,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACAlE,QAAQ,CAACmC,SAAS,CAACoF,UAAU,GAAG,UAAUxD,OAAO,EAAE;EAC/C,IAAIkD,aAAa;EAEjB,IAAI,OAAOlD,OAAO,CAACE,IAAI,KAAK,UAAU,EAAE;IACpC;IACA,OAAOF,OAAO;EAClB,CAAC,MAAM,IAAIA,OAAO,IAAI,OAAOA,OAAO,CAACgF,IAAI,KAAK,QAAQ,IAAI,CAAChF,OAAO,CAACiF,IAAI,EAAE;IACrE,IAAI,IAAI,CAACrI,iBAAiB,EAAE;MACxBsG,aAAa,GAAG,IAAIxH,WAAW,CAAC,CAAC;MACjC+H,YAAY,CAAC,YAAY;QACrBP,aAAa,CAACH,IAAI,CAAC,OAAO,EAAE,IAAImC,KAAK,CAAC,2BAA2B,GAAGlF,OAAO,CAACgF,IAAI,CAAC,CAAC;MACtF,CAAC,CAAC;MACF,OAAO9B,aAAa;IACxB;IACA;IACA,OAAOvH,EAAE,CAACgF,gBAAgB,CAACX,OAAO,CAACgF,IAAI,CAAC;EAC5C,CAAC,MAAM,IAAIhF,OAAO,IAAI,OAAOA,OAAO,CAACiF,IAAI,KAAK,QAAQ,EAAE;IACpD,IAAI,IAAI,CAACpI,gBAAgB,EAAE;MACvBqG,aAAa,GAAG,IAAIxH,WAAW,CAAC,CAAC;MACjC+H,YAAY,CAAC,YAAY;QACrBP,aAAa,CAACH,IAAI,CAAC,OAAO,EAAE,IAAImC,KAAK,CAAC,0BAA0B,GAAGlF,OAAO,CAACiF,IAAI,CAAC,CAAC;MACrF,CAAC,CAAC;MACF,OAAO/B,aAAa;IACxB;IACA;IACA,OAAOtH,KAAK,CAACoE,OAAO,CAACiF,IAAI,CAAC;EAC9B,CAAC,MAAM;IACH;IACA/B,aAAa,GAAG,IAAIxH,WAAW,CAAC,CAAC;IACjC+H,YAAY,CAAC,YAAY;MACrBP,aAAa,CAACF,GAAG,CAAChD,OAAO,IAAI,EAAE,CAAC;IACpC,CAAC,CAAC;IACF,OAAOkD,aAAa;EACxB;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAjH,QAAQ,CAACmC,SAAS,CAACmG,eAAe,GAAG,UAAUK,SAAS,EAAE;EACtD,OAAO,EAAE,CAACzD,MAAM,CAACgE,KAAK,CAAC,EAAE,EAAE,EAAE,CAAChE,MAAM,CAACyD,SAAS,CAAC,CAACF,GAAG,CAAC,UAAUD,OAAO,EAAE;IACnE,IAAIA,OAAO,IAAIA,OAAO,CAACA,OAAO,EAAE;MAC5BA,OAAO,GAAG,IAAI,CAACH,iBAAiB,CAACG,OAAO,CAAC;IAC7C;IACA,OAAOjJ,aAAa,CAACiJ,OAAO,CAAC;EACjC,CAAC,CAAC3F,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA7C,QAAQ,CAACmC,SAAS,CAACsB,mBAAmB,GAAG,UAAUR,GAAG,EAAE;EACpD,OAAO,CAACA,GAAG,IAAI,EAAE,EAAE1C,QAAQ,CAAC,CAAC;EACzB;EACJmC,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC,CACzBrB,IAAI,CAAC,CAAC,CAACgE,WAAW,CAAC,CAAC;EAChB;EACJ3C,OAAO,CAAC,kEAAkE,EAClE,UAAUyG,CAAC,EAAE;IACT,OAAOA,CAAC,CAAC5H,WAAW,CAAC,CAAC;EAC1B,CAAC,CAAC;EACN;EACJmB,OAAO,CAAC,sBAAsB,EAAE,kBAAkB,CAAC;AACvD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA1C,QAAQ,CAACmC,SAAS,CAACkE,kBAAkB,GAAG,UAAUP,UAAU,EAAE;EAC1D,IAAI,CAAC7F,WAAW,GAAG6F,UAAU,CAAC5C,KAAK,CAAC7B,IAAI,CAAC,CAAC,CAACgE,WAAW,CAAC,CAAC;EAExD,IAAI,CAACyC,SAAS,GAAG,IAAI,CAAC7H,WAAW,CAACiB,KAAK,CAAC,GAAG,CAAC,CAACkI,MAAM,CAAC,UAAUC,IAAI,EAAEnG,KAAK,EAAE;IACvE,OAAOmG,IAAI,KAAK,WAAW,GAAGnG,KAAK,GAAG,KAAK;EAC/C,CAAC,CAAC;EAEF,IAAI,IAAI,CAAC4E,SAAS,EAAE;IAChB,IAAI,CAACF,QAAQ,GAAG9B,UAAU,CAACK,MAAM,CAACyB,QAAQ,GAAG9B,UAAU,CAACK,MAAM,CAACyB,QAAQ,IAAI,IAAI,CAACA,QAAQ,IAAI,IAAI,CAAC0B,iBAAiB,CAAC,CAAC;EACxH,CAAC,MAAM;IACH,IAAI,CAAC1B,QAAQ,GAAG,KAAK;EACzB;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA5H,QAAQ,CAACmC,SAAS,CAACmH,iBAAiB,GAAG,YAAY;EAC/C,OAAO,IAAI,CAACxI,QAAQ,CAACJ,cAAc,GAAG,MAAM,GAAG,IAAI,CAACiB,OAAO,GAAG,GAAG,GAAG,IAAI,CAACb,QAAQ,CAACV,YAAY;AAClG,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAJ,QAAQ,CAACmC,SAAS,CAACsE,kBAAkB,GAAG,UAAUxD,GAAG,EAAEC,KAAK,EAAE;EAC1DD,GAAG,GAAG,IAAI,CAACQ,mBAAmB,CAACR,GAAG,CAAC;EAEnC,QAAQA,GAAG;IAEP;IACA,KAAK,MAAM;IACX,KAAK,QAAQ;IACb,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,KAAK;IACV,KAAK,UAAU;MACX,OAAO,IAAI,CAACoF,iBAAiB,CAAC,IAAI,CAACC,eAAe,CAACpF,KAAK,CAAC,CAAC;;IAE1D;IACJ,KAAK,YAAY;IACjB,KAAK,aAAa;IAClB,KAAK,YAAY;MACbA,KAAK,GAAG,CAACA,KAAK,IAAI,EAAE,EAAE3C,QAAQ,CAAC,CAAC,CAACmC,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC;MAE1D,IAAIQ,KAAK,CAAC5B,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QACzB4B,KAAK,GAAG,GAAG,GAAGA,KAAK;MACvB;MAEA,IAAIA,KAAK,CAAC5B,MAAM,CAAC4B,KAAK,CAACH,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;QACxCG,KAAK,GAAGA,KAAK,GAAG,GAAG;MACvB;MACA,OAAOA,KAAK;;IAEZ;IACJ,KAAK,YAAY;MACbA,KAAK,GAAG,EAAE,CAACgC,MAAM,CAACgE,KAAK,CAAC,EAAE,EAAE,EAAE,CAAChE,MAAM,CAAChC,KAAK,IAAI,EAAE,CAAC,CAACuF,GAAG,CAAC,UAAUc,GAAG,EAAE;QAClEA,GAAG,GAAG,CAACA,GAAG,IAAI,EAAE,EAAEhJ,QAAQ,CAAC,CAAC,CAACmC,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC,CAACrB,IAAI,CAAC,CAAC;QAC7D,OAAOkI,GAAG,CAAC7G,OAAO,CAAC,UAAU,EAAE,UAAU8G,GAAG,EAAE;UAC1C,OAAOA,GAAG,CAAC9G,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;QACjC,CAAC,CAAC,CAACxB,KAAK,CAAC,KAAK,CAAC;MACnB,CAAC,CAAC,CAAC,CAACuH,GAAG,CAAC,UAAUc,GAAG,EAAE;QACnB,IAAIA,GAAG,CAACjI,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;UACvBiI,GAAG,GAAG,GAAG,GAAGA,GAAG;QACnB;QACA,IAAIA,GAAG,CAACjI,MAAM,CAACiI,GAAG,CAACxG,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;UACpCwG,GAAG,GAAGA,GAAG,GAAG,GAAG;QACnB;QACA,OAAOA,GAAG;MACd,CAAC,CAAC;MAEF,OAAOrG,KAAK,CAACyD,IAAI,CAAC,GAAG,CAAC,CAACtF,IAAI,CAAC,CAAC;IAEjC,KAAK,MAAM;MACP,IAAIkC,MAAM,CAACpB,SAAS,CAAC5B,QAAQ,CAAC6G,IAAI,CAAClE,KAAK,CAAC,KAAK,eAAe,EAAE;QAC3D,OAAOA,KAAK,CAACyC,WAAW,CAAC,CAAC,CAACjD,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC;MACtD;MAEAQ,KAAK,GAAG,CAACA,KAAK,IAAI,EAAE,EAAE3C,QAAQ,CAAC,CAAC,CAACmC,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC;MAC1D,OAAO,IAAI,CAAC8D,YAAY,CAACtD,KAAK,CAAC;IAEnC;MACIA,KAAK,GAAG,CAACA,KAAK,IAAI,EAAE,EAAE3C,QAAQ,CAAC,CAAC,CAACmC,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC;MAC1D;MACA,OAAO,IAAI,CAAC8D,YAAY,CAACtD,KAAK,CAAC;EACvC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAlD,QAAQ,CAACmC,SAAS,CAACkG,iBAAiB,GAAG,UAAUM,SAAS,EAAEc,UAAU,EAAE;EACpE,IAAIC,MAAM,GAAG,EAAE;EAEfD,UAAU,GAAGA,UAAU,IAAI,EAAE;EAE7B,EAAE,CAACvE,MAAM,CAACyD,SAAS,IAAI,EAAE,CAAC,CAAChG,OAAO,CAAC,UAAU6F,OAAO,EAAE;IAClD,IAAIA,OAAO,CAACA,OAAO,EAAE;MACjBA,OAAO,CAACA,OAAO,GAAGA,OAAO,CAACA,OAAO,CAAC9F,OAAO,CAAC,MAAM,EAAE,UAAUiH,MAAM,EAAE;QAChE;QACA;QACA;QACA;QACA,OAAO,GAAG,GAAGrK,QAAQ,CAACsK,OAAO,CAACD,MAAM,CAACE,MAAM,CAAC,CAAC,CAAC,CAAC;MACnD,CAAC,CAAC;MAEF,IAAI,CAACrB,OAAO,CAACsB,IAAI,EAAE;QACfJ,MAAM,CAACjH,IAAI,CAAC+F,OAAO,CAACA,OAAO,CAAC;MAChC,CAAC,MAAM,IAAIA,OAAO,CAACsB,IAAI,EAAE;QACrBJ,MAAM,CAACjH,IAAI,CAAC,IAAI,CAACsH,kBAAkB,CAACvB,OAAO,CAACsB,IAAI,CAAC,GAAG,IAAI,GAAGtB,OAAO,CAACA,OAAO,GAAG,GAAG,CAAC;MACrF;MAEA,IAAIA,OAAO,CAACA,OAAO,EAAE;QACjB,IAAI,CAACiB,UAAU,CAAClB,MAAM,CACd,UAAUyB,CAAC,EAAE;UACT,OAAOA,CAAC,CAACxB,OAAO,KAAKA,OAAO,CAACA,OAAO;QACxC,CAAC,CAAC,CAACzF,MAAM,EAAE;UACf0G,UAAU,CAAChH,IAAI,CAAC+F,OAAO,CAAC;QAC5B;MACJ;IACJ,CAAC,MAAM,IAAIA,OAAO,CAACyB,KAAK,EAAE;MACtBP,MAAM,CAACjH,IAAI,CAAC,IAAI,CAACsH,kBAAkB,CAACvB,OAAO,CAACsB,IAAI,CAAC,GAAG,GAAG,GAAG,CAACtB,OAAO,CAACyB,KAAK,CAAClH,MAAM,GAAG,IAAI,CAACsF,iBAAiB,CAACG,OAAO,CAACyB,KAAK,EAAER,UAAU,CAAC,GAAG,EAAE,EAAEpI,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC;IAC3J;EACJ,CAAC,CAACwB,IAAI,CAAC,IAAI,CAAC,CAAC;EAEb,OAAO6G,MAAM,CAAC/C,IAAI,CAAC,IAAI,CAAC;AAC5B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA3G,QAAQ,CAACmC,SAAS,CAAC4H,kBAAkB,GAAG,UAAUD,IAAI,EAAE;EACpD,IAAI,CAAC,WAAW,CAACvE,IAAI,CAACuE,IAAI,CAAC,EAAE;IACzB,IAAI,gBAAgB,CAACvE,IAAI,CAACuE,IAAI,CAAC,EAAE;MAC7B,OAAO,GAAG,GAAGA,IAAI,CAACpH,OAAO,CAAC,UAAU,EAAE,MAAM,CAAC,GAAG,GAAG;IACvD,CAAC,MAAM;MACH,OAAOxD,OAAO,CAACgL,UAAU,CAACJ,IAAI,EAAE,IAAI,CAACtE,gBAAgB,CAACsE,IAAI,CAAC,EAAE,EAAE,CAAC;IACpE;EACJ;EACA,OAAOA,IAAI;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA9J,QAAQ,CAACmC,SAAS,CAACqE,YAAY,GAAG,UAAUtD,KAAK,EAAE;EAC/C,OAAOhE,OAAO,CAACiL,WAAW,CAACjH,KAAK,EAAE,IAAI,CAACsC,gBAAgB,CAACtC,KAAK,CAAC,EAAE,EAAE,CAAC;AACvE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAlD,QAAQ,CAACmC,SAAS,CAACqD,gBAAgB,GAAG,UAAUtC,KAAK,EAAE;EACnDA,KAAK,GAAG,CAACA,KAAK,IAAI,EAAE,EAAE3C,QAAQ,CAAC,CAAC;EAEhC,IAAI6J,QAAQ,GAAG,IAAI,CAAChJ,YAAY;EAChC,IAAIiJ,QAAQ;EACZ,IAAIC,WAAW;EAEf,IAAI,CAACF,QAAQ,EAAE;IACX;IACA;IACA;IACAE,WAAW,GAAG,CAACpH,KAAK,CAACoD,KAAK,CAAC,4CAA4C,CAAC,IAAI,EAAE,EAAEvD,MAAM;IACtFsH,QAAQ,GAAG,CAACnH,KAAK,CAACoD,KAAK,CAAC,SAAS,CAAC,IAAI,EAAE,EAAEvD,MAAM;IAChD;IACAqH,QAAQ,GAAGE,WAAW,GAAGD,QAAQ,GAAG,GAAG,GAAG,GAAG;EACjD;EACA,OAAOD,QAAQ;AACnB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACApK,QAAQ,CAACmC,SAAS,CAAC0G,kBAAkB,GAAG,YAAY;EAChD,OAAO,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAACO,MAAM;EACxB;EACA,UAAUC,IAAI,EAAE3F,GAAG,EAAE;IACjB,OAAO2F,IAAI,GAAG,GAAG,GAAGzJ,MAAM,CAAC2K,WAAW,CAAC7G,GAAG,CAAC,CAACnD,QAAQ,CAAC,KAAK,CAAC;EAC/D,CAAC,EAAEX,MAAM,CAAC2K,WAAW,CAAC,CAAC,CAAC,CAAChK,QAAQ,CAAC,KAAK,CAAC,CAAC,GAC7C,GAAG;EACH;EACA,CAAC,IAAI,CAACqI,WAAW,CAAC,CAAC,CAACT,IAAI,IAAI,IAAI,CAAC1G,QAAQ,IAAI5B,EAAE,CAAC4B,QAAQ,CAAC,CAAC,IAAI,WAAW,EAAEP,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAC,CAAC,GAAG,GAAG;AACzG,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}